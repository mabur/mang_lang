MANGLANG SCOPE
{
	module = {
    c = 1,
    constant = from x to c,
  },
  c = 2,
	constant = constant module,
  x = constant []
}
TODO: x should be 1 and not 2
SOLUTION:
  - for each node in AST we keep a mutable field with the latest value it was evaluated to.
  - We let lookups point to a node in the AST.

PHASES
* construction of AST (pass environment in this stage as well, to link lookups)
* (type checking)
* (compilation / code generation)
* evaluation of program

IMPLEMENTATION
* Outside of function body.
  - Symbols are refering to constant values.
  - The symbols could be assigned when constructing the AST.
    - But let's skip it for simplicity.
  - The symbols could share immutable data using pointers.
    - But let's skip it for simplicity.
* Inside function body.
  - Symbols are potentially refering to variable values.
  - The values can be assigned each time the function is called.
  - It is harder to share data in this context.
  - Let's create copies for each assignment.
* What do we get when we evaluate a symbol refering to a functions, with possible captures?
  - How about functions as input to functions?
  - How about functions as output of functions?
  - How about recursion?
    - If we send function A to function B, then we only 

AST
Expression, Number, String, Array, Dictionary, Function, Lookup, Conditional, ArrayComprehension


!"#¤%&/()=?`^*{[]}\´´~¨'",.-;:_

RAW VALUES:
Number : number : 3.0
String : string : "magnus"

COMBINED EXPRESSIONS:
Conditional : (expression, expression, expression) : if 1 then 2 else 3
Array : [expression] : [1, 2]

CONTEXT:
Dictionary : {string: expression} : {x=1, y=2}
Function : (string, expression) : from x to 1
ArrayComprehension : (string, expression, array, condition?) : each f x for x in y if g x
change order so that symbol is defined before it is used?
for x in y if g x get f x
or same as function
map y from x to f x if g x

LOOKUP:
VariableLookup in current dictionary: (expression*) : x
DictionaryLookup in sub dictionary: (string, Dictionary) : width-rectangle   
FunctionLookup : (function*, expression) : area rectangle


How can we differentiate between dictionary-lookup and function call when constructing AST?
* Using another token than space like -
* Using types
* Fallback to function if a function with that name exists in the environment when constructing AST
* Store pointer to function if it exists when constructing the AST,
  but wait until evaluation-pass to decide if it is function-lookup or dictionary-lookup

house = house city country
house = house-city-country
house = house of city of country
house = country.city.house

name = person.name.first
name = first-name-person
tail = tail-list


EVALUATION
Evaluate the AST starting from the root.
Generate new nodes on the fly.
Keep an environment of symbols for each open node.
Do we need more environments to handle closures?
Number -> Number
String -> String
Array -> Array: [element.evaluate() for element in array]
Dictionary -> Dictionary: {k: v.evaluate() for k, v in dictionaty.items()}
Conditional -> Expression: if statement then first.evaluate() else second.evaluate()
Function -> Function?
LookupSymbol -> Expression?
LookupFunction -> Expression (extend environment)
ArrayComprehension -> Array (extend environment)

Kan LookupSymbol bara titta på den environment som hör till den nod som evalueras i trädet?
Då kan man väl inte hantera symboler i function capture?

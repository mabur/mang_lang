MANGLANG SCOPE
{
  x = 1,
  barn = {
    x = 2,
    barnbarn = {
      x = 3
    },
    y = x,
    y = x barnbarn,
    y = x PARENT,
    y = x barn PARENT,
    add = add GLOBAL
  }
}
{
	module = {
    c = 1,
    constant = from x to c,
  },
  c = 2,
	constant = constant module,
  x = constant []
}
TODO: x should be 1 and not 2
SOLUTION:
  - for each node in AST we keep a mutable field with the latest value it was evaluated to.
  - We let lookups point to a node in the AST.

PHASES
* construction of AST (pass environment in this stage as well, to link lookups)
* (type checking)
* (compilation / code generation)
* evaluation of program

IMPLEMENTATION
* Outside of function body.
  - Symbols are refering to constant values.
  - The symbols could be assigned when constructing the AST.
    - But let's skip it for simplicity.
  - The symbols could share immutable data using pointers.
    - But let's skip it for simplicity.
* Inside function body.
  - Symbols are potentially refering to variable values.
  - The values can be assigned each time the function is called.
  - It is harder to share data in this context.
  - Let's create copies for each assignment.
* What do we get when we evaluate a symbol refering to a functions, with possible captures?
  - How about functions as input to functions?
  - How about functions as output of functions?
  - How about recursion?
    - If we send function A to function B, then we only 
* Differentiate between static dictionaries (that can have functions) and dynamic dictionaries (that cannot have functions)

AST
Expression, Number, String, Array, Dictionary, Function, Lookup, Conditional

!"#¤%&/()=?`^*{[]}\´´~¨'",.-;:_

RAW VALUES:
Number : number : 3.0
String : string : "magnus"

COMBINED EXPRESSIONS:
Array : [expression] : [1, 2]

CONTEXT:
StaticDictionary : {string: expression} : {x=1, y=2, f = from a to add(a, x)}
DynamicDictionary : {string: expression} : {x=1, y=2}
Function : (string, expression) : from x to 1

LOOKUP:
ConditionalLookup : (expression, expression, expression) : if 1 then 2 else 3
StaticVariableLookup in current (or parent) dictionary: (expression*) : x
DynamicVariableLookup in current (or parent) dictionary: (expression*) : x
StaticDictionaryLookup in sub dictionary: (string, Dictionary) : width-rectangle   
DynamicDictionaryLookup in sub dictionary: (string, Dictionary) : width-rectangle   
FunctionLookup : (function*, expression) : area rectangle

PHASE TOKENS->AST

PHASE AST->AST WITH STATIC LOOKUPS
Pass along environment so that symbols in AST can point to nodes.

AST WITH STATIC LOOKUPS->VALUE
Pass along environment so that symbols in call stack can be looked up.

EVALUATION
Evaluate the AST starting from the root.
Generate new nodes on the fly.
Keep an environment of symbols for each open node.
Do we need more environments to handle closures?
Number -> Number
String -> String
Array -> Array: [element.evaluate() for element in array]
Dictionary -> Dictionary: {k: v.evaluate() for k, v in dictionaty.items()}
Conditional -> Expression: if statement then first.evaluate() else second.evaluate()
Function -> Function?
LookupSymbol -> Expression?
LookupFunction -> Expression (extend environment)

Kan LookupSymbol bara titta på den environment som hör till den nod som evalueras i trädet?
Då kan man väl inte hantera symboler i function capture?


AST
Number
String
Array
Dictionary
Function
ConditionalLookup
VariableLookup
DictionaryLookup
FunctionLookup

STATICALLY EVALUATED AST
Number
String
Array
StaticDictionary
DynamicDictionary
Function
ConditionalLookup
StaticVariableLookup
DynamicVariableLookup
StaticDictionaryLookup
DynamicDictionaryLookup
FunctionLookup



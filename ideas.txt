WITH DEFINITION (=) OF FUNCTIONS R^N->R^N

conjugate(x) = (x(0), neg(x(1)))

conjugate(x) = {
    real_in = x[0]
    imaginary_in = x[1]
    real_out = real_in
    imaginary_out = neg(imaginary)
} = (real_out, imaginary_out)

x = (1, 2)   // (1, 2)
result = conjugate(x) // (1, -2)

sqr(z) = z * z
distance(x1,y1,x2,y2) = {
    xdistance = sub(x2, x1),
    ydistance = sub(y2, y1)
} = sqrt(add(sqr(xdistance), sqr(ydistance)))

abs(x) = {
    condition = greater(x, 0),
    alternative0 = x,
    alternative1 = neg(x)
    } = if condition then alternative0 else alternative1


PATTERN MATCHING / UNPACKING (skip)

// variable with unpacking
point = (x=3, y=5)
(x, y) = point

// function output with unpacking
minmax(x) = {...} = (min, max)
elements = (1, 7, 4, 9, 7)
(min, max) = minmax(elements)
result = add(min, max)


HELPER SYMBOLS
Have a grammer that does not allow chaining of function calls or tuple indexing or definition lookup. Force the use of helper symbols.


TEXT REPRESENTATION
Define three text representations for the language:
1. Raw source code as raw text file.
2. Abstract syntax tree as jason.
3. Evaluated tree as jason.


TUPLES

a = (8, 9)    // (8, 9)
x = mul(a)    // 72
y = 5         // 5
z = add(x, y) // 77

c = (4, 5, 6, 7) // (4, 5, 6, 7)
n = size(c)      // 4
d = c[1]         // 5
e = c(1:2)       // (5, 6)  implement slicing later
f = concat((d), e, a) // (5, 5, 6, 8, 9)

b = is_empty(c)
a = first(tuple)
b = last(tuple)
c = without_first(tuple)
d = without_last(tuple)


LIST COMPREHENSION FOR MAP AND FILTER

a = (f(x) for x in collection if g(x))
a = (f(x) : x in collection and g(x))
a = all f(x) for x in collection if g(x)

// Fold<
faculty = left_fold collection with 1 by mul
sum     = left_fold collection with 0 by add
minimum = left_fold collection with MAX_FLOAT by min
maximum = left_fold collection with MIN_FLOAT by max

// Unfold
a = unfold 0 by next until greater_than(10)
a = from 0; greater_than(10); next
a = for x=0; x <= 10; next(x)
a = (x for geq(0, x) and leq(x, 10))

// linspace
a = (0,1,...,10)
N = 10
delta = div(1,N)
a = (0,delta,...,1)
a = range(0, 10)

delta = div(sub(end, start), 10)
a = (start, ..., end)


STANDARD LIBRARY

Start writing standard library functions in Mang Lang instead of Python.


IMPORT

Import source code as new namespace:

(
x = (1,2,3),
std = import("std.ml"),
f = std.first(x)
)

Import source code into current namespace:

(
x = (1,2,3),
import("std.ml"),
f = std.first(x)
// TODO: fix referencing for functions first

)

STRINGS

Tuple of characters.
Convert to tuple of characters when parsing.
Convert back to "string" notation when storing as json?

x = "hej"
y = "world"
z = concat(x, y)
a = x[0] // return string of length 1.
m = size(x)
b = "h" (how to represent individual characters?)
z = x[end] // TODO?
w = x[end-2]


BOOLEAN

Have same primitive types as in json? Number, string, bool?
What about individual characters?


READ OR WRITE TO TEXT FILES

content = read_text("data.txt")
content = text_file("data.txt")
write_text("data.txt", content)
text_file("data.txt") = content


STACKED OPERATIONS
(
a=(b=(c=1,d(x)=mul(x,x))),
a[0][0],
a.b.c,
a.b.d(2)
)

indexing = (symbol and "[" and index and "]") or (expression and "[" and index and "]")
lookup = (symbol and "." and symbol) or (expression and "." and symbol)
call = (symbol and expression) or (expression and expression)

Det blir väl svårare att parsa när ordningen är tvärtom?
Alternativ: Eller ska man implementera den parsningen baklänges?

Alternativ: Uttryck som funktioner. Skulle något bli enklare av det?
index(tuple, i)
lookup(object, member_name)
eller låt () ha speciel betydelse för tuple:
tuple(i)
object(member_name)
(
a=(b=(c=1,d(x)=mul(x,x))),
a(0)(0),
a(b)(c),
a(b)(d)(2)
)
std(min)(3, 2)

Alternativ: tillåt inte kedjning, utan bara en "operation" per expression.
En annan fördel med det är att man tvingas införa hjälpvariabler för sammansatta uttryck.
Då behöver jag dock hantera funktionspekare.

FUNCTION POINTERS / REFERENCES / ALIASES

MODULES & SCOPE

main.ml
(
std = import("std.ml"),
a = 3,
f(x) = 4,
b = (
    c = 5,
    g(x) = 7
    )
h(x) = {
       k(y) = 8,
       u = mul(x, x)
       } = k(u),
d = (1, 2, 3),
sum = std.sum,
e = sum(d)
)

std.ml
(
arithmetic = (
             sum = ...
             ),
order = (
        min = ...
        max = ...
        ),
pi = 3.14,
sin(x) = ...,
cos(x) = {half_pi = div(pi, 2), y = add(x, half_pi)}, sin(y),
increment(x) = {f(y) = add(y, x)} = f
)

TODO:
Add support for calling of functions via several references:
a.f(b)
Do that before supporting "copying" of functions:
c = a.f
c(b)

First step can be to implement regexp-like functionality on my own, and use that for both lexing and parsing.


REGEXP FUNCTIONALITY

NUMBER = "[+-]?([0-9]+[.])?[0-9]+"
PARENTHESIS_BEGIN = "\("
PARENTHESIS_END = "\)"
BRACKET_BEGIN = "\["
BRACKET_END = "\]"
SCOPE_BEGIN = "\{"
SCOPE_END = "\}"
EQUAL = "="
COMMA = ","
DOT = "\."
IF = "if"
THEN = "then"
ELSE = "else"
IMPORT = "import"
ALL = "all"  # TODO: rename to "each"?
FOR = "for"
IN = "in"
SYMBOL = "[a-z_]\\w*"
STRING = "\"\w*\""
WHITE_SPACE = " "
NEW_LINES = "\n"

_parse_number, [TokenType.NUMBER]
_parse_string, [TokenType.STRING]
_parse_conditional, [TokenType.IF]
_parse_tuple_comprehension, [TokenType.ALL]
_parse_import, [TokenType.IMPORT]
_parse_function_definition, [TokenType.SYMBOL, TokenType.PARENTHESIS_BEGIN, TokenType.SYMBOL, TokenType.PARENTHESIS_END, TokenType.EQUAL]
_parse_function_call, [TokenType.SYMBOL, TokenType.PARENTHESIS_BEGIN]
_parse_indexing, [TokenType.SYMBOL, TokenType.BRACKET_BEGIN]
_parse_definition_lookup, [TokenType.SYMBOL, TokenType.DOT, TokenType.SYMBOL]
_parse_variable_definition, [TokenType.SYMBOL, TokenType.EQUAL]
_parse_reference, [TokenType.SYMBOL]
_parse_tuple, [TokenType.PARENTHESIS_BEGIN]
_parse_scope, [TokenType.SCOPE_BEGIN]

a.b.c
a.b.c()

* Fix sekvens
* optional (0 eller 1) av element från någon mängd. högst 1.
* 1 eller godtyckligt många av element från någon mängd. minst 1.
* godtyckligt antal. minst 0
* ihopslagningar av mönstren ovan.
* Stöd karaktärer / tokens av godtycklig typ.

digit = anyof([0,1,2,3,4,5,6,7,8,9])
letter = anyof([a,b,c,...])
sign = anyof([+,-])
if_key_word = sequence([i,f])

a=if_key_word
b=atmost(1, sign)
c=atleast(1, letter)
d=atleast(0, digit)
e=sequence([a,b,c,d])
g=atmost(1, e)

// Exempel:
a.b.c()
symbol = atleast(1, letters)
dot = sequence([.])
indirection = sequence((symbol, dot))
optional_indirection = atleast(0, indirection)
open_parenthesis = sequence([(])
function_call = sequence((optional_indirection, symbol, open_parenthesis))

def sequence(x: Sequence[Token]) -> Pattern
def atmost(n: int, x: Sequence[Token]) -> Pattern
def atleast(n: int, x: Sequence[Token]) -> Pattern
def match_pattern(x: Sequence[Token], pattern: Pattern) -> Pair[int, int]
def match_patterns(x: Sequence[Token], patterns: Sequence[Pattern]) -> Sequence[Pair[int, int]]:
    return [match_pattern(x, pattern) for pattern in patterns]
Den sista funktionen kanske är onödigt enkel för att ha som del av bibliotek.
Kanske lättare att skriva den själv och anpassa till just de behov man har.

class Pattern:
    def match(self, x: Sequence):

NY IDÈ

Kanske blir lättare om man har rekursiv definition av indirection:
indirection = symbol . expression
istället för
symbol.symbol

Code representations:
* source
* lexed sequence of tokens (maybe multiple steps)
* ast (not json, but can be converted to json)
* evaluated tree (not json, but can be converted to json)
  Uses same node types as ast, but all constants substituted etc.
  It is possible to have recursive data structures in Python, but not with Mypy annotation.

TODO:
* Make result of "evaluate" methods be Expression nodes. Convert to json outside of the methods, in the calling function "interpret".

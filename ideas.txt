TUPLES

a = (8, 9)    // (8, 9)
x = mul(a)    // 72
y = 5         // 5
z = add(x, y) // 77

c = (4, 5, 6, 7) // (4, 5, 6, 7)
n = size(c)      // 4
d = c[1]         // 5
e = c(1:2)       // (5, 6)  implement slicing later
f = concat((d), e, a) // (5, 5, 6, 8, 9)

b = is_empty(c)
a = first(tuple)
b = last(tuple)
c = without_first(tuple)
d = without_last(tuple)


FOLD

// Fold<
faculty = left_fold collection with 1 by mul
sum     = left_fold collection with 0 by add
minimum = left_fold collection with MAX_FLOAT by min
maximum = left_fold collection with MIN_FLOAT by max

// Unfold
a = unfold 0 by next until greater_than(10)
a = from 0; greater_than(10); next
a = for x=0; x <= 10; next(x)
a = (x for geq(0, x) and leq(x, 10))

// linspace
a = (0,1,...,10)
N = 10
delta = div(1,N)
a = (0,delta,...,1)
a = range(0, 10)

delta = div(sub(end, start), 10)
a = (start, ..., end)


READ OR WRITE TO TEXT FILES

content = read_text("data.txt")
content = text_file("data.txt")
write_text("data.txt", content)
text_file("data.txt") = content


MODULES & SCOPE

main.ml
(
std = import("std.ml"),
a = 3,
f(x) = 4,
b = (
    c = 5,
    g(x) = 7
    )
h(x) = {
       k(y) = 8,
       u = mul(x, x)
       } = k(u),
d = (1, 2, 3),
sum = std.sum,
e = sum(d)
)

std.ml
(
arithmetic = (
             sum = ...
             ),
order = (
        min = ...
        max = ...
        ),
pi = 3.14,
sin(x) = ...,
cos(x) = {half_pi = div(pi, 2), y = add(x, half_pi)}, sin(y),
increment(x) = {f(y) = add(y, x)} = f
)


REGEXP FUNCTIONALITY

NUMBER = "[+-]?([0-9]+[.])?[0-9]+"
PARENTHESIS_BEGIN = "\("
PARENTHESIS_END = "\)"
BRACKET_BEGIN = "\["
BRACKET_END = "\]"
SCOPE_BEGIN = "\{"
SCOPE_END = "\}"
EQUAL = "="
COMMA = ","
DOT = "\."
IF = "if"
THEN = "then"
ELSE = "else"
IMPORT = "import"
ALL = "all"  # TODO: rename to "each"?
FOR = "for"
IN = "in"
SYMBOL = "[a-z_]\\w*"
STRING = "\"\w*\""
WHITE_SPACE = " "
NEW_LINES = "\n"

_parse_number, [TokenType.NUMBER]
_parse_string, [TokenType.STRING]
_parse_conditional, [TokenType.IF]
_parse_tuple_comprehension, [TokenType.ALL]
_parse_import, [TokenType.IMPORT]
_parse_function_definition, [TokenType.SYMBOL, TokenType.PARENTHESIS_BEGIN, TokenType.SYMBOL, TokenType.PARENTHESIS_END, TokenType.EQUAL]
_parse_function_call, [TokenType.SYMBOL, TokenType.PARENTHESIS_BEGIN]
_parse_indexing, [TokenType.SYMBOL, TokenType.BRACKET_BEGIN]
_parse_definition_lookup, [TokenType.SYMBOL, TokenType.DOT, TokenType.SYMBOL]
_parse_variable_definition, [TokenType.SYMBOL, TokenType.EQUAL]
_parse_reference, [TokenType.SYMBOL]
_parse_tuple, [TokenType.PARENTHESIS_BEGIN]
_parse_scope, [TokenType.SCOPE_BEGIN]

a.b.c
a.b.c()

* Fix sekvens
* optional (0 eller 1) av element från någon mängd. högst 1.
* 1 eller godtyckligt många av element från någon mängd. minst 1.
* godtyckligt antal. minst 0
* ihopslagningar av mönstren ovan.
* Stöd karaktärer / tokens av godtycklig typ.

digit = anyof([0,1,2,3,4,5,6,7,8,9])
letter = anyof([a,b,c,...])
sign = anyof([+,-])
if_key_word = sequence([i,f])

a=if_key_word
b=atmost(1, sign)
c=atleast(1, letter)
d=atleast(0, digit)
e=sequence([a,b,c,d])
g=atmost(1, e)

// Exempel:
a.b.c()
symbol = atleast(1, letters)
dot = sequence([.])
indirection = sequence((symbol, dot))
optional_indirection = atleast(0, indirection)
open_parenthesis = sequence([(])
function_call = sequence((optional_indirection, symbol, open_parenthesis))

def sequence(x: Sequence[Token]) -> Pattern
def atmost(n: int, x: Sequence[Token]) -> Pattern
def atleast(n: int, x: Sequence[Token]) -> Pattern
def match_pattern(x: Sequence[Token], pattern: Pattern) -> Pair[int, int]
def match_patterns(x: Sequence[Token], patterns: Sequence[Pattern]) -> Sequence[Pair[int, int]]:
    return [match_pattern(x, pattern) for pattern in patterns]
Den sista funktionen kanske är onödigt enkel för att ha som del av bibliotek.
Kanske lättare att skriva den själv och anpassa till just de behov man har.

class Pattern:
    def match(self, x: Sequence):


HELPER SYMBOLS
Have a grammer that does not allow chaining of function calls or tuple indexing or definition lookup. Force the use of helper symbols.


STANDARD LIBRARY

Start writing standard library functions in Mang Lang instead of Python.


BOOLEAN

Have same primitive types as in json? Number, string, bool?
What about individual characters?

TYPES
square(x:real):real = mul(x, x)
vec2(x:real, y:real):type
type(x:real, y:real):vec2
vec2(x:real, y:real):vec2
vec2(x:real, y:real)
vec2 = (x:real, y:real)
(x:real, y:real):vec2
point = vec2(1,-1)
point = typeof((x=0, y=0))
prototype = (x=0, y=0)
point = typeof(prototype)

square = (real x) -> (real mul(x,x))
hypo = (real x, real y) -> (real add(square(x),square(y)))
conj = (real re, real im) -> (real re, real neg(im))
conj = (complex c) -> (complex {re=c.re, im=neg(c.im)})
c1 = complex {re=1,im=1}
c2 = conj(c1)
im re = conj 1 2
im,re = conj(1,2)
im re = conj(1 2)
(im, re) = conj(1, 2)

Handle definitions as dicts. Have dicts and arrays as basic containers instead of tuple.

TYPES
origin2d = (x=0, y=0)
//Vec2 = type(origin2d))
//Vec2 = type(x=0, y=0)
Vec2 = (x: Real, y: Real)
//point1 = Vec2()
point2 = Vec2(1, 1)
//Ray2 = type(start=(0,0), direction=(1,1))
Ray = (start: Vec2, direction: Vec2)
// Behövs default-värden? Nej.
// Behövs konstruktorer? Ja.
square(x: Real): Real = mul(x, x)
square(x: Real) = mul(x, x)
square(x) = mul(x, x)
square = (x: Real) -> mul(x, x): Real
square = (x: Real) -> mul(x, x)
square = (x) -> mul(x, x)
square = x -> mul(x, x)
square_distance =
  (a: Vec2, b: Vec2) ->
  (dx=sub(a.x,b.x), dy=sub(a.y,b.y), dx2=mul(dx,dx), dy2=mul(dy, dy)) ->
  add(dx2, dy2): Real
square_distance =
  (a: Vec2, b: Vec2) ->
  (dx=sub(a.x,b.x), dy=sub(a.y,b.y)) ->
  (dx2=mul(dx,dx), dy2=mul(dy, dy)) ->
  add(dx2, dy2): Real
// Variables with local scope:
square_distance =
  (a: Vec2, b: Vec2) ->
  (dx=sub(a.x,b.x), dy=sub(a.y,b.y)) ->
  (dx2=mul(dx,dx), dy2=mul(dy, dy)) ->
  add(dx2, dy2): Real
square_distance =
  (a: Vec2, b: Vec2) ->
  {dx=sub(a.x,b.x), dy=sub(a.y,b.y), dx2=mul(dx,dx), dy2=mul(dy, dy)} ->
  add(dx2, dy2): Real

square_distance: (Vec2, Vec2) -> Real =
  (a: Vec2, b: Vec2) ->
  {dx=sub(a.x,b.x), dy=sub(a.y,b.y), dx2=mul(dx,dx), dy2=mul(dy, dy)} ->
  add(dx2, dy2): Real
square_distance =
  (Vec2 a, Vec2 b) -> Real
  {dx=sub(a.x,b.x), dy=sub(a.y,b.y), dx2=mul(dx,dx), dy2=mul(dy, dy)} ->
  add(dx2, dy2)

Vec2 = (x=Real, y=Real)
point = (x=Real 0, y=Real 0)
point = Vec2 (x=0, y=0)
point = (x=0, y=0)
hyp(x, y) = sqrt(add(mul(x, x), mul(y, y)))
hyp = (x, y) -> sqrt(add(mul(x, x), mul(y, y)))
hyp = (x=Real, y=Real) -> Real sqrt(add(mul(x, x), mul(y, y)))
hyp = Vec2 -> Real sqrt(add(mul(x, x), mul(y, y)))
Hyp = (x=Real, y=Real) -> Real


// Alternativ 1 (klass till primitiv):
square = (x=Number) -> Number mul(left=x, right=x)
nine = square((x=3))
five = hyp((x=3,y=4))
vec  = Vec2((x=3, y=4))
five = hyp(vec)
// Alternativ 2 (klass till primitiv):
square = (x=Number) -> Number mul(left=x, right=x)
nine = square(x=3)
five = hyp(x=3,y=4)
vec  = Vec2(x=3,y=4)
five = hyp vec
five = hyp(vec) optional alternativ 3

Ordnings-regel: symbol = typ värde
Rule: types start with upper case. variables start with lower case.


FUNKTIONS-DEFINITIONER

// Klass till primitiv:
hyp = (x=Real, y=Real) -> Real sqrt(add(mul(x, x), mul(y, y)))
Real hyp(Real x, Real y) = sqrt(add(mul(x, x), mul(y, y)))
square = (x=Number) -> Number mul(left=x, right=x)
Number square(Number x) = mul(x, x)

// Primitiv till primitiv:
square(x)=mul(x,x)
square x = mul x x
square : Number -> Number
square(x=Number) = Number mul(x,x)
square x = {x is a number} = mul x x
square x = mul x x where x is a Number
square(x)=mul(x,x) where x is a Number
assuming x is a Number let
square(x)=mul(x,x)
square = x -> mul(x, x) where x is a Number

// Tuppel till tuppel
conjugate(a, b) = (a, neg(b))
conjugate a b = a neg(b)
conjugate : Number x Number -> Number x Number
conjugate(a, b) = (a, neg(b)) where a is a Number and b is a Number
conjugate = (a, b) -> (a, neg(b)) where a is a Number and b is a Number
assuming a is a Number and b is a Number let
conjugate(a, b) = (a, neg(b))

// Klass/tuppel till klass:
conjugate(Real r, Imag i) = (Real r=r, Imag i=neg(i))
conjugate : (Real r, Imag i) -> (Real r, Imag i)
conjugate = (r=Real, i=Imag) -> (r=Real r, i=Imag neg(i))
conjugate = (r:Real, i:Imag) -> (r:Real=r, i:Imag=neg(i))
conjugate = (Real r, Imag i) -> (Real r=r, Imag i=neg(i))
conjugate = {a, b} -> {a=a, b=neg(b)} where a is Number and b is Number

// Klass variabel
Complex = (re=Number, im=Number)
complex = (re=1, im=1)
re = complex.re
im = complex.im
conjugate = c -> (re = c.re, im = neg(c.im)) where c is Complex
complex2 = conjugate(complex1)


TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real, y=Real)
*Array?
*Enum?

DICT / TUPLE / ARRAY / TABLE / LUA
a = (1, 2)
b = (x=1, y=2)
add2 = (l, r) -> (add(l[0], r[0]), add(l[1], r[1]))
c = add2(a, b)
hyp1 = (v) -> sqrt(add(mul(v[0], v[0]), mul(v[1], v[1])))
hyp2 = (x, y) -> sqrt(add(mul(x, x), mul(y, y)))
h1 = hyp1(a)
h2 = hyp2(1, 2)
conj1 = (c) -> (re=c.re, im=c.im)
conj2 = (im, re) -> (re=re, im=im)
c1 = (1,2)
c2 = (re=1, im=2)
c3 = conj1(c1) # error tuple c1 has no members re and im
c4 = conj1(c2)
c5 = conj1((re=1, im=2)) # implicit packing
c6 = conj2(1, 2)
c7 = conj2(*c1) # implicit unpacking
c8 = conj2(*c2) # implicit unpacking
(a,b) = conj1(c1)

SINGLE ARGUMENT FUNCTIONS (ENKELT & BRA)
a = [1, 2]
b = [3, 4]
add2 = x -> [add([x[0][0], x[1][0]]), add([x[0][1], x[1][1]])]
add2 = terms -> {
  left = terms[0],
  right = terms[1],
  x = [left[0], right[0]],
  y = [left[1], right[1]]
  } -> [add(x), add(y)]
constant = {three = 3, decimals = 0.14}
         = add(three, decimals)
c = add2([a, b])
hyp1 = v -> {
  x = v[0],
  y = v[1],
  x2 = mul([x, x]),
  y2 = mul([y, y]),
  } -> sqrt(add([x2, y2]))
h1 = hyp1(a)
h2 = hyp1([1, 2])
conj1 = c -> [re=c[0], im=c[1]]
c1 = [re=1, im=2]
c2 = conj1(c1)
c3 = conj1([re=1, im=2])

dot2 = vectors -> (
    a = vectors[0],
    b = vectors[1],
    ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1],
) -> add[mul[ax, bx], mul[ay, by]]
) -> [[ax, bx].mul, [ay, by].mul].add

dot2 = FROM vectors WHERE (
    a = vectors[0],
    b = vectors[1],
    ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1],
) TO add[mul[ax, bx], mul[ay, by]]
) TO [[ax, bx].mul, [ay, by].mul].add
) TO [[ax, bx]->mul, [ay, by]->mul]->add

square_norm2 = vector -> dot2[vector, vector]
square_norm2 = vector -> [vector, vector].dot2

sub2 = vectors -> (
    a = vectors[0],
    b = vectors[1],
    ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1],
    x = [ax, bx].sub,
    y = [ay, by].sub,
) -> [x, y]

sub2 = from vectors where
{
    a = vectors[0],
    b = vectors[1],
    ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1],
    x = sub[ax, bx],
    y = sub[ay, by],
} to [x, y]

square_distance2 = from vectors to square_norm2(sub2(vectors))
square_distance2 = from vectors to square_norm2 sub2 vectors
square_distance2 = from vectors to vectors sub2 square_norm
square_distance2 = from vectors to vectors|sub2|square_norm
square_distance2 = from vectors to vectors.sub2.square_norm
square_distance2 = from vectors to vectors->sub2->square_norm

Liknande Ruby och Python-properties. Ha punkt . för både:
1. slå upp medlems-variabel.
2. applicera funktion/metod.
Men hur blir det då med metoder/funktioner definierade i det egna objektet?
Hur ska man applicera en metod på objektet?
Men vad är vitsen med medlemsfunktioner istället för medlemsvariablar om objektet är immutable?
Kan fortfarande vara en vits med medlemsfunktioner, om de inte bara jobbar på self.
[1,2,3]|std.min
Slutsats: gör inte så.

my_vec =
{
  x = 1,
  y = 2,
  squared_norm2 = from v to dot[v,v]
  proj = from a to dot[a, [x, y]]
}


square_distance2 = from vectors where
{
    delta = sub2 vectors,
} to square_norm2 delta

TUPLE / ARRAYS / DICT / SCOPES
* Array []
* Dict {}
* Scope
* Tuple
* Function call

()
[]
{}
<>
||

ARRAY lookup

sub2 = from vectors where
{
    a = vectors 0,
    b = vectors 1,
    ax = a 0,
    ay = a 1,
    bx = b 0,
    by = b 1,
    x = sub[ax, bx],
    y = sub[ay, by],
} to [x, y]

sub_vec = from vector_pair to
    all sub dimension for dimension in zip vector_pair

def sub_vec(vector0, vector1):
    return [c0 - c1 for c0, c1 in zip(vector0, vector1)]

TODO:
* Types, and input format for functions.
  How to handle tuples and tuples of definitions?
  Keyword arguments?
  Use dict instead of tuple as main building block.
  Treat functions as values first?
* Parse tokens and Expressions similarly.
  Can peek for starting sequences.
  Handle optional starting sequences, by implementing it as multiple ParsePatterns.
* Allow capital letters in symbols.
* Allow more characters in strings, especially . / \ needed for filenames
* Remove indexing?
* zip


split = from input where
(
  queue  = input.queue,
  query  = input.query,
  result = recursive_split(queue=queue, query=query, result=())
) to result.result

recursive_split = from input where
(
  queue  = input.queue,
  query  = input.query,
  result = input.result,
) to if is_empty queue then input
else
(
  find_result = find(list=queue, query=','),
  tail        = find_result.tail,
  head        = find_result.head,
  result      = concat[result, [head]]
  output      = recursive_split(queue=tail, result=result)
).output


// Take a list and return a pair of lists: head and tail, or head, query, tail
find = ...
find_inclusive = ...
find_exclusive = ...

[1,2,3,4]

find(list=[1,2,3,4], query=3)
-> (head=[1,2], query=[3], tail=[4])

Parse "123,+56,345,-76,23"

parse_element = from input to find(list=input.string, query=',')

def split(input, query):
  output = []
  last_split_index = 0
  for index, element in enumerate(input):
      if element == query:
        word = input[last_split_index:index]
        output.append(word)
  return output

def split(input_query):
  def f(a, b):
    return
  return fold(input_query, [], f)

def eat(source, target, query)
  if source and source[0] != query:
    front = source.pop_front()
    target = target.push_back(front)
  return (source, target, query)


eat_until = from input to
if is_empty input.source then
   input
else if equal(get_first input.source, query) then 
  (
    target = input.target,
    source = pop_first input.source
  )
else
  eat_until
  (
    target = concat(input.target, (get_first(input.source))),
    source = pop_first(input.source),
    query = query
  )


INDIRECTION

triangle =
(
  points =
  (
    (x=1,y=2),
    (x=1,y=2),
    (x=1,y=2)
  )
)

triangle.points.x
x in points in triangle

point = (x=1,y=2,z=3)

square(world.point.x)
conjugate(world.point).x
vector_functions.conjugate(world.point).x // C style
world.point.conjugate.x // Ruby style

square world.point.x     // ambiguous without parenthesis
conjugate world.point.x  // ambiguous without parenthesis

square of x in point in world
x in conjugate of point in world
x in conjugate in vector_functions of point in world       // Ambiguous
x of conjugate of vector_functions of point of world       // Ambiguous
x in ((conjugate in vector_functions) of (point in world))
x in (conjugate in vector_functions of (point in world))   // Evaluate from left to right
x in (conjugate in vector_functions) of point in world     // Evaluate from right to left
conjugate = conjugate in vector_functions // Only allow evaluation from right to left with expresions.
x in conjugate of point in world          // like: symbol preposition expression. Makes parsing easier.
x in conjugate of point in world where (conjugate = conjugate in vector_functions)

world.points|(vector_functions.conjugate).x

Might be less ambiguous and easier to parse if both function call and indirection are prefix operators.
Alternatively they could both be postfix operators,
but prefix seems easier in my parser and more similar to other constructs like if, comprehension, function.

What prepositions? in of from.
* in, of
* from, of
* of, of  // Use same. Similar as Ruby, but inverse order. Maybe also for arrays. Seems nice!

square_distance2 = from vectors to square_norm2(sub2(line.points))
square_distance2 = from vectors to square_norm2 sub2 line.points
square_distance2 = from vectors to square_norm2 sub2 points line
square_distance2 = from vectors to square_norm2 sub2 points in line
square_distance2 = from vectors to square_norm2 of sub2 of points in line
square_distance2 = from vectors to square_norm2 of sub2 of points of line
square_distance2 = from vectors to vectors sub2 square_norm line.points
square_distance2 = from vectors to line.points|sub2|square_norm
square_distance2 = from vectors to line.points.sub2.square_norm
square_distance2 = from vectors to line.points->sub2->square_norm
square_distance2 = from vectors to line pick points apply sub2 apply square_norm

min in std of queue
std.min(queue)

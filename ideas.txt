SINGLE EXPRESSION

Builtin functions R^N->R
add, mul, sub, div, neg, pow, ln, sin, cos, tan

add(5, mul(8, 9)) // 5 + 8 * 9


number = ...
number_array = "(", number {"," number} ")"
expression = number or array or symbol ( expression )


expression = number | constant | array | function_call
number = 123...
constant = symbol
symbol = abc...
array = "(" [expression {"," expression}] ")"
function_call = symbol, array


WITH DEFINITION (=) OF CONSTANT VARIABLES

One definition per line:

x = mul(8, 9) // (72)
y = 5         // 5
z = add(x, y) // 77

ARRAYS

a = (8, 9)    // (8, 9)
x = mul(a)    // 72
y = 5         // 5
z = add(x, y) // 77

c = (4, 5, 6, 7) // (4, 5, 6, 7)
n = size(c)      // 4
d = a(1)         // 5
e = c(1:2)       // (5, 6)  implement slicing later
f = (d, e)       // (5, 5, 6)


WITH DEFINITION (=) OF FUNCTIONS R->R

cube(x) = mul(x, mul(x, x))

cube(x) = {x2 = mul(x, x)} = mul(x, x2)


WITH DEFINITION (=) OF FUNCTIONS R^N->R^N

conjugate(x) = (x(0), neg(x(1)))

conjugate(x) = {
    real_in = x(0)
    imaginary_in = x(1)
    real_out = real_in
    imaginary_out = neg(imaginary)
} = (real_out, imaginary_out)

x = (1, 2)   // (1, 2)
result = conjugate(x) // (1, -2)


HASKELL
distance (x1,y1) (x2,y2) = 
  let xdistance = x2 - x1
      ydistance = y2 - y1
      sqr z = z*z in
  in sqrt((sqr xdistance) + (sqr ydistance))

distance (x1,y1) (x2,y2) = sqrt((sqr xdistance) + (sqr ydistance))
where
  xdistance = x2 - x1
  ydistance = y2 - y1
  sqr z = z*z

ME
sqr = z -> z*z
distance = (x1,y1,x2,y2) ->
    xdistance = sub(x2, x1)
    ydistance = sub(y2, y1)
    sqrt(add(sqr(xdistance), sqr(ydistance)))

sqr(z) = z * z
distance(x1,y1,x2,y2) = {
    xdistance = sub(x2, x1)
    ydistance = sub(y2, y1)
    } = sqrt(add(sqr(xdistance), sqr(ydistance)))


SUBROUTINES

pi =
    a = 3.0
    b = 0.14
    add(a, b)

pi = {a = 3.0, b = 0.14} = add(a, b)

pi = {
    a = 3.0,
    b = 0.14
} = add(a, b)


CONTROL STRUCTURES

if/choose, and, or, not, equal, greater, smaller as built in functions operating on R^N

abs(x) = {
    condition = greater(x, 0)
    alternative0 = x
    alternative1 = neg(x)
    } = ifthenelse(condition, alternative0, alternative1)


DEFINITION OF CONTEXT
A context is a dictionary of definitions. It is indexed by the names of the defined variables and functions.

Result is a special symbol. If it exists in the context, then it is the value of the context. Otherwise the context has no value.

LOCAL ANONYMOUS CONTEXT & ENVIRONMENT

a = 3.0
b = 0.14
result = a + b

(a = 3.0, b = 0.14, result = a + b)

result = {a = 3.0, b = 0.14} = a + b

abs(x) = {
    condition = greater(x, 0),
    alternative0 = x,
    alternative1 = neg(x)
} = ifthenelse(condition, alternative0, alternative1)

abs(x) = {condition = greater(x, 0), alternative0 = x, alternative1 = neg(x)} = ifthenelse(condition, alternative0, alternative1)


NAMED CONTEXT & ENVIRONMENT

// variable without unpacking
point = (x=3, y=5)
result = point.x + point.y

single = (data=5)
result = single.data

// function input without unpacking
max(x, y) = ifthenelse(greater(x, y), x, y)

// function output without unpacking
minmax(x) = {...} = (min=...; max=...)
elements = (1,7,4,9,7)
mm = minmax(elements)
result = add(mm.min, mm.max)


PATTERN MATCHING / UNPACKING (skip)

// variable with unpacking
point = (x=3, y=5)
(x, y) = point

// function output with unpacking
minmax(x) = {...} = (min, max)
elements = (1, 7, 4, 9, 7)
(min, max) = minmax(elements)
result = add(min, max)


GRAMMAR

symbol = ...
number = ...
expression = number or symbol or function_call or variable_definition or function_definition or tuple or tuple_indexing or definition_lookup
tuple = expressions
function_call = symbol and tuple
variable_definition = symbol and expression
function_definition = symbol and tuple and expression
tuple_indexing = symbol and expression
definition_lookup = symbol and symbol


Do not allow chaining of function calls or tuple indexing or definition lookup.
Force the use of helper symbols.


GRAMMAR 1

symbol = ...
number = ...
expression = number or symbol or function_call or tuple
tuple = expressions
function_call = symbol and tuple


GRAMMAR 2

symbol = ...
number = ...
expression = number or symbol or function_call or tuple or variable_definition
tuple = expressions
function_call = symbol and tuple
variable_definition = symbol and expression


GRAMMAR 3

symbol = ...
number = ...
expression = number or symbol or function_call or tuple_indexing or tuple or variable_definition
tuple = expressions
function_call = symbol and tuple
variable_definition = symbol and expression
tuple_indexing = symbol and expression


GRAMMAR 4

symbol = ...
number = ...
expression = number or symbol or function_call or tuple_indexing or definition_lookup or tuple or variable_definition
tuple = expressions
function_call = symbol and tuple
variable_definition = symbol and expression
tuple_indexing = symbol and expression
definition_lookup = symbol and symbol

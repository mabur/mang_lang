TODO:
* Fix scope handling
* Try to implement Advent od Code problems to see what is missing
* Unpacking dicts for multiple input and output of functions
* zip
* Konsekvent indentering
* Start writing standard library functions in Mang Lang instead of Python.
* Pattern matching.

-------------------------------------------------------------------------------------------------
PATTERN MATCHING FOR SYMBOLS IN RECORDS AND FUNCTION INPUT
{
  // Lists
  conjugate = from x to [first x, neg last x],
  conjugate = from [a, b] to [a, neg b],
  p0 = [1, 2],
  p1 = conjugate p0,
  [x1, y1] = conjugate p0,

  // Records
  conjugate = from c to {re = re c, im = neg im c},
  conjugate = from {re, im} to {re = re, im = neg im},
  p0 = {re = 1, im = 2},
  p1 = conjugate p0,
  {re1, im1} = conjugate p0,
}
-------------------------------------------------------------------------------------------------

TYPES
Types start with upper case. Variables start with lower case.

FUNKTIONS-DEFINITIONER

Ordnings-regel 1:  symbol = typ : värde
Ordnings- regel 2: symbol : typ = värde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number, im:Number}
Complex : Type = {re:Number, im:Number}
x : Distance = 3
square : Number = mul[x, x]

// primitive to primitive:
square : to = mul[x, x]
square : Number to Number = mul[x, x]

// record to primitive:
hyp : {x:Number, y:Number} to Number = sqrt add[mul[x, x], mul[y, y]

// list to list
conjugate : to = [first x, neg last x]
conjugate : List Number to List Number = [first x, neg last x]

// record to record:
conjugate : {r, i} to = {r := r, i := neg i}
conjugate : {r:Number, i:Number} to {r:Number, i:Number} = {r := r, i := neg i}

// Klass variabel
Complex := {re: Number, im: Number}
complex := {re:=1, im:=1}
complex : Complex = {re : Number = 1, im : Number = 1}
re = re complex
im = im complex
conjugate : {r:Number, i:Number} to {r:Number, i:Number} = {r := r, i := neg i}
conjugate : Complex to Complex = {r := r, i := neg i}
complex2 = conjugate complex1

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real, y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)

-------------------------------------------------------------------------------------------------

split = from input to result of
{
  queue  = queue of input,
  query  = query of input,
  result = recursive_split of {queue=queue, query=query, result=[]}
}

recursive_split = from input to
    if check_empty of queue of input
    then input
    else output of
    {
      find_result = find of {list=queue, query=","}, // Relies on find/split_first
      tail        = tail of find_result,
      head        = head of find_result,
      result      = concat of [result, [head]]
      output      = recursive_split of {queue=tail, result=result}
    }

move_element = from input to
    if check_equality of [front of source, query of input] then undefined else
    {
        target = concat of [target of input, front of source of input],
        source = without_front of source of input,
        query = query of input
    }
move_word = move_element unfold {source=,target=[], query=","}
    


// Take a list and return a pair of lists: head and tail, or head, query, tail
find = ...
find_inclusive = ...
find_exclusive = ...

[1,2,3,4]

find(list=[1,2,3,4], query=3)
-> (head=[1,2], query=[3], tail=[4])

Parse "123,+56,345,-76,23"

parse_element = from input to find(list=input.string, query=',')

def split_for(input, query):
  output = []
  last_split_index = 0
  for index, element in enumerate(input):
      if element == query:
        word = input[last_split_index + 1:index]
        output.append(word)
        last_split_index = index
  word = input[last_split_index + 1:]
  if word:
    output.append(word)
  return output

def split_generator(first, last, query):
  if first != last:
    next = find_if(first, last, query)
    yield [first, next]
    yield from split_generator(++next, last, query)

// Denna verkar enkel. Skulle liknande funka i Manglang?
def split_recursive(first, last, query):
  if first == last:
    return []
  next = find_if(first, last, query)
  return [[first, next]] + split_generator(++next, last, query)


// Recursive split in Python:
def split_recursive(source, query):
  if not source:
    return []
  word, rest = next_word(source, query)
  return [word] + split_recursive(rest, query)

def next_word(source, query):
  if not source:
      return [], []
  if source[0] == query:
    return [], source[1:]
  word, rest = next_word(source[1:], query)
  return [source[0]] + word, rest

// Iterator split in C++:
std::vector<std::string> split(first, last, char query) {
  using namespace std;
  auto result = vector<string>{};
  auto next = find(first, last, query);
  do {
    if (first != next) {
      result.append(string{first, next});
    }
    first = ++next;
    next = find(first, last, query);
  } while (next != last)
  return result;
}

// Recursive split in C++:
std::vector<std::string> split_recursive(std::string source, char query)
{
    if (source.empty())
        return {};
    auto split = next_word(source, query);
    auto word = split[0];
    auto rest = split[1];
    auto recursive_result = split_recursive(rest, query);
    recursive_result.push_front(word);
    return recursive_result;
}

std::tuple<std::string, std::string> next_word(std::string source, char query) {
    using namespace std;
    if (source.empty)
        return make_tuple("", "");
    if (source[0] == query)
        return {{}, source.substr(1)};
    auto split = next_word(source.substr(1), query);
    auto word = get<0>(split);
    auto rest = get<1>(split);
    return make_tuple(source[0] + word, rest);
}

// Recursive split in Mang lang:
split_recursive = from input to
    if is_empty of source of input then
        []
    else
        result of {
            query = query of input,
            source = source of input,
            split = next_word of {source = source, query = query},
            word = word of split,
            rest = rest of split,
            recursive_result = split_recursive of {source = rest, query = query},
            result = concat of [word, recursive_result]
        }

next_word = from input to
    if is_empty of source of input then
        {word = [], rest = []}
    else if check_equality of [first of source of input, query of input] then
        {word = [], rest = last_part of source of input}
    else
        result of {
            source = source of input,
            query = query of input,
            tail = last_part of source,
            split = next_word of {source = tail, query = query},
            word = word of split,
            rest = rest of split,
            result = {word = concat of [[first of source], word], rest = rest}
        }

// Multiple named input/output for functions:
split_recursive = from source, query to
    if is_empty of source then
        []
    else
        result of {
            word, rest = next_word of {source = source, query = query},
            recursive_result = split_recursive of {source = rest, query = query},
            result = concat of [word, recursive_result]
        }

next_word = from source, query to
    if is_empty of source then
        {word = [], rest = []}
    else if check_equality of [first of source, query] then
        {word = [], rest = last_part of source}
    else
        result of {
            word, rest = next_word of {source = last_part of source, query = query},
            result = {word = concat of [[first of source], word], rest = rest}
        }

// Blir bra. Implementera algoritmer från STL som find, find_if,
// men som returnerar listor istället för arrayer.
// find ger ger listorna [first, it] [it, end],
// där it kan vara end ifall den inte hittar något.
// next word ovan är typ find_if.

// F#
let find list query =
    match list width
        [] -> [[]; []]
        [query:] -> [[]; list]
        _ ->
            let [head: tail] = list
            let [center; new_tail] = find tail query
            let new_head = [head] + center
            [new_head, new_tail]

// Python
def find(list, query):
    if not list:
        return [[], []]
    if list[0] == query:
        return [[], list]
    center, tail = find(list=list[1:], query=query)
    head = [list[0]] + center
    return [head, tail]

// Nuvarande
find = from input to
    if is_empty list input then
        [[],[]]
    else if are_equal [first list input, query input] then
        [[], list input]
    else
        result {
            list = list input,
            query = query input,
            recursive_result = find {list=last_part list, query=query}
            head = concat [[first list], first recursive_result],
            tail = last recursive_result,
            result = [head, tail]
        }

// Multiple input & output of functions
find = from {list, query} to
    if is_empty list then
        [[],[]]
    else if are_equal [first list, query] then
        [[], list]
    else
        result {
            [center, tail] = find {list=last_part list, query=query}
            head = concat [[first list], center],
            result = [head, tail]
        }

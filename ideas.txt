TUPLES

a = (8, 9)    // (8, 9)
x = mul(a)    // 72
y = 5         // 5
z = add(x, y) // 77

c = (4, 5, 6, 7) // (4, 5, 6, 7)
n = size(c)      // 4
d = c[1]         // 5
e = c(1:2)       // (5, 6)  implement slicing later
f = concat((d), e, a) // (5, 5, 6, 8, 9)

b = is_empty(c)
a = first(tuple)
b = last(tuple)
c = without_first(tuple)
d = without_last(tuple)


FOLD

// Fold<
faculty = left_fold collection with 1 by mul
sum     = left_fold collection with 0 by add
minimum = left_fold collection with MAX_FLOAT by min
maximum = left_fold collection with MIN_FLOAT by max

// Unfold
a = unfold 0 by next until greater_than(10)
a = from 0; greater_than(10); next
a = for x=0; x <= 10; next(x)
a = (x for geq(0, x) and leq(x, 10))

// linspace
a = (0,1,...,10)
N = 10
delta = div(1,N)
a = (0,delta,...,1)
a = range(0, 10)

delta = div(sub(end, start), 10)
a = (start, ..., end)


READ OR WRITE TO TEXT FILES

content = read_text("data.txt")
content = text_file("data.txt")
write_text("data.txt", content)
text_file("data.txt") = content


MODULES & SCOPE

main.ml
(
std = import("std.ml"),
a = 3,
f(x) = 4,
b = (
    c = 5,
    g(x) = 7
    )
h(x) = {
       k(y) = 8,
       u = mul(x, x)
       } = k(u),
d = (1, 2, 3),
sum = std.sum,
e = sum(d)
)

std.ml
(
arithmetic = (
             sum = ...
             ),
order = (
        min = ...
        max = ...
        ),
pi = 3.14,
sin(x) = ...,
cos(x) = {half_pi = div(pi, 2), y = add(x, half_pi)}, sin(y),
increment(x) = {f(y) = add(y, x)} = f
)


REGEXP FUNCTIONALITY

NUMBER = "[+-]?([0-9]+[.])?[0-9]+"
PARENTHESIS_BEGIN = "\("
PARENTHESIS_END = "\)"
BRACKET_BEGIN = "\["
BRACKET_END = "\]"
SCOPE_BEGIN = "\{"
SCOPE_END = "\}"
EQUAL = "="
COMMA = ","
DOT = "\."
IF = "if"
THEN = "then"
ELSE = "else"
IMPORT = "import"
ALL = "all"  # TODO: rename to "each"?
FOR = "for"
IN = "in"
SYMBOL = "[a-z_]\\w*"
STRING = "\"\w*\""
WHITE_SPACE = " "
NEW_LINES = "\n"

_parse_number, [TokenType.NUMBER]
_parse_string, [TokenType.STRING]
_parse_conditional, [TokenType.IF]
_parse_tuple_comprehension, [TokenType.ALL]
_parse_import, [TokenType.IMPORT]
_parse_function_definition, [TokenType.SYMBOL, TokenType.PARENTHESIS_BEGIN, TokenType.SYMBOL, TokenType.PARENTHESIS_END, TokenType.EQUAL]
_parse_function_call, [TokenType.SYMBOL, TokenType.PARENTHESIS_BEGIN]
_parse_indexing, [TokenType.SYMBOL, TokenType.BRACKET_BEGIN]
_parse_definition_lookup, [TokenType.SYMBOL, TokenType.DOT, TokenType.SYMBOL]
_parse_variable_definition, [TokenType.SYMBOL, TokenType.EQUAL]
_parse_reference, [TokenType.SYMBOL]
_parse_tuple, [TokenType.PARENTHESIS_BEGIN]
_parse_scope, [TokenType.SCOPE_BEGIN]

a.b.c
a.b.c()

* Fix sekvens
* optional (0 eller 1) av element från någon mängd. högst 1.
* 1 eller godtyckligt många av element från någon mängd. minst 1.
* godtyckligt antal. minst 0
* ihopslagningar av mönstren ovan.
* Stöd karaktärer / tokens av godtycklig typ.

digit = anyof([0,1,2,3,4,5,6,7,8,9])
letter = anyof([a,b,c,...])
sign = anyof([+,-])
if_key_word = sequence([i,f])

a=if_key_word
b=atmost(1, sign)
c=atleast(1, letter)
d=atleast(0, digit)
e=sequence([a,b,c,d])
g=atmost(1, e)

// Exempel:
a.b.c()
symbol = atleast(1, letters)
dot = sequence([.])
indirection = sequence((symbol, dot))
optional_indirection = atleast(0, indirection)
open_parenthesis = sequence([(])
function_call = sequence((optional_indirection, symbol, open_parenthesis))

def sequence(x: Sequence[Token]) -> Pattern
def atmost(n: int, x: Sequence[Token]) -> Pattern
def atleast(n: int, x: Sequence[Token]) -> Pattern
def match_pattern(x: Sequence[Token], pattern: Pattern) -> Pair[int, int]
def match_patterns(x: Sequence[Token], patterns: Sequence[Pattern]) -> Sequence[Pair[int, int]]:
    return [match_pattern(x, pattern) for pattern in patterns]
Den sista funktionen kanske är onödigt enkel för att ha som del av bibliotek.
Kanske lättare att skriva den själv och anpassa till just de behov man har.

class Pattern:
    def match(self, x: Sequence):


HELPER SYMBOLS
Have a grammer that does not allow chaining of function calls or tuple indexing or definition lookup. Force the use of helper symbols.


STANDARD LIBRARY

Start writing standard library functions in Mang Lang instead of Python.


BOOLEAN

Have same primitive types as in json? Number, string, bool?
What about individual characters?

TODO:
* Parse tokens and Expressions similarly.
  Can peek for starting sequences.
  Handle optional starting sequences, by implementing it as multiple ParsePatterns.
* Allow capital letters in symbols.
* Allow more characters in strings, especially . / \ needed for filenames

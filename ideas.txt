WITH DEFINITION (=) OF FUNCTIONS R^N->R^N

conjugate(x) = (x(0), neg(x(1)))

conjugate(x) = {
    real_in = x[0]
    imaginary_in = x[1]
    real_out = real_in
    imaginary_out = neg(imaginary)
} = (real_out, imaginary_out)

x = (1, 2)   // (1, 2)
result = conjugate(x) // (1, -2)

sqr(z) = z * z
distance(x1,y1,x2,y2) = {
    xdistance = sub(x2, x1),
    ydistance = sub(y2, y1)
} = sqrt(add(sqr(xdistance), sqr(ydistance)))

abs(x) = {
    condition = greater(x, 0),
    alternative0 = x,
    alternative1 = neg(x)
    } = if condition then alternative0 else alternative1


PATTERN MATCHING / UNPACKING (skip)

// variable with unpacking
point = (x=3, y=5)
(x, y) = point

// function output with unpacking
minmax(x) = {...} = (min, max)
elements = (1, 7, 4, 9, 7)
(min, max) = minmax(elements)
result = add(min, max)


HELPER SYMBOLS
Have a grammer that does not allow chaining of function calls or tuple indexing or definition lookup. Force the use of helper symbols.


TEXT REPRESENTATION
Define three text representations for the language:
1. Raw source code as raw text file.
2. Abstract syntax tree as jason.
3. Evaluated tree as jason.


TUPLES

a = (8, 9)    // (8, 9)
x = mul(a)    // 72
y = 5         // 5
z = add(x, y) // 77

c = (4, 5, 6, 7) // (4, 5, 6, 7)
n = size(c)      // 4
d = c[1]         // 5
e = c(1:2)       // (5, 6)  implement slicing later
f = concat((d), e, a) // (5, 5, 6, 8, 9)

b = is_empty(c)
a = first(tuple)
b = last(tuple)
c = without_first(tuple)
d = without_last(tuple)


LIST COMPREHENSION FOR MAP AND FILTER

a = (f(x) for x in collection if g(x))
a = (f(x) : x in collection and g(x))
a = all f(x) for x in collection if g(x)

// Fold<
faculty = left_fold collection with 1 by mul
sum     = left_fold collection with 0 by add
minimum = left_fold collection with MAX_FLOAT by min
maximum = left_fold collection with MIN_FLOAT by max

// Unfold
a = unfold 0 by next until greater_than(10)
a = from 0; greater_than(10); next
a = for x=0; x <= 10; next(x)
a = (x for geq(0, x) and leq(x, 10))

// linspace
a = (0,1,...,10)
N = 10
delta = div(1,N)
a = (0,delta,...,1)
a = range(0, 10)

delta = div(sub(end, start), 10)
a = (start, ..., end)


STANDARD LIBRARY

Start writing standard library functions in Mang Lang instead of Python.


IMPORT

Import source code as new namespace:

(
x = (1,2,3),
std = import("std.ml"),
f = std.first(x)
)

Import source code into current namespace:

(
x = (1,2,3),
import("std.ml"),
f = std.first(x)
)

STRINGS

Tuple of characters.
Convert to tuple of characters when parsing.
Convert back to "string" notation when storing as json?

x = "hej"
y = "world"
z = concat(x, y)
a = x[0] // return string of length 1.
m = size(x)
b = "h" (how to represent individual characters?)
z = x[end] // TODO?


BOOLEAN

Have same primitive types as in json? Number, string, bool?
What about individual characters?


READ OR WRITE TO TEXT FILES

content = read_text("data.txt")
content = text_file("data.txt")
write_text("data.txt", content)
text_file("data.txt") = content

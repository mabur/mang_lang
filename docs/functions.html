<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mali">
<link rel="stylesheet" href="styles.css">
<title>Manglang Functions</title>
</head>
<body>

<h1>Functions</h1>

<p>
Below you can find all functions included with Manglang. They are either built-in or implemented in the
<a href="https://github.com/mabur/mang_lang/blob/master/src/built_in_functions/standard_library.h">standard library</a>.
</p>

<h2>Time Complexity</h2>
<p>
For all container functions we specify how the time complexity depends on the number of elements N in the container. So an operation that is marked as O(1) takes the same time for small and large containers. An operation that is marked as O(N) takes twice as long for a container that is twice as big.
</p>

<h2>Container Interface</h2>
Manglang has containers like: stacks, strings, tables. They share an interface of basic operations:
<dl>
<dt>take</dt><dd><code>take!container</code> returns a single item from the container. O(1).</dd>
<dt>drop</dt><dd><code>drop!container</code> returns the container with a single item dropped from it. O(1).</dd>
<dt>put</dt><dd><code>put!(item container)</code> returns a new container with item added to the old container. For tables we have that <code>put!((key value) table)</code> sets the value corresponding to the key in the table and returns the table. For stacks and strings the original container is not mutated, but it is mutated for tables so that other references to it are effected as well! O(1).</dd>
<dt>clear</dt><dd><code>clear!container</code> returns an empty container of the same type as the input. O(1).</dd>
<dt>indexing</dt><dd><code>container!index</code> can be used to get the item at the specified index. The container is interpreted as a function which takes an index as input and outputs an item. O(N).</dd>
</dl>
The relationship of these functions can be expressed as <code>put!(take!container drop!container)</code> gives back just the <code>container</code>. Furthermore, we check if a container is not empty by <code>if container then ... else ...</code> O(1).

<p>
The operations can be used as a base for building more container functions. The standard library does that and adds all the functions below.
</p>

<h2>Generic Container Functions</h2>
These functions work on both stacks, strings, tables, and the type of the output container is the same as the input.
We use the word container to represent either a stack, string or table.
<dl>
<dt>fold</dt><dd><code>fold!(binary_operation container init)</code> is mainly used as an algorithmic building block to implement the other container functions. O(N).</dd>
<dt>reverse</dt><dd><code>reverse!container</code> returns a container with the items in the reverse order for stacks and string. For tables we just get a copy, since a table is always sorted by its keys. O(N).</dd>
</dl>
<dl>
<dt>take</dt><dd><code>take!container</code> returns a single item from the container. O(1).</dd>
<dt>take_many</dt><dd><code>take_many!(n container)</code> returns a new containers with n items taken from the input container. O(n).</dd>
<dt>take_while</dt><dd><code>take_while!(predicate container)</code> returns a new containers with items taken from the input container as long as the predicate says yes. O(N).</dd>
<dt>take_until_item</dt><dd><code>take_until_item!(item container)</code> returns a new containers with items taken from the input container until the query item is found. O(N).</dd>
</dl>
<dl>
<dt>drop</dt><dd><code>drop!container</code> returns the container with a single item dropped from it. O(1).</dd>
<dt>drop_many</dt><dd><code>drop_many!(n container)</code> returns the container with n items dropped from it. O(n).</dd>
<dt>drop_while</dt><dd><code>drop_while!(predicate container)</code> returns the container with items dropped from it as long as the predicate says yes. O(N).</dd>
<dt>drop_until_item</dt><dd><code>drop_until_item!(item container)</code> returns a container with items dropped until the query item is found. O(N).</dd>
</dl>
<dl>
<dt>clear</dt><dd><code>clear!container</code> returns an empty container of the same type as the input. O(1).</dd>
<dt>clear_item</dt><dd><code>clear_item!(item container)</code> returns a container with all occurances of the specified item removed. O(N).</dd>
<dt>clear_if</dt><dd><code>clear_if!(predicate container)</code> returns a container without the items for which the predicate says <code>yes</code>. O(N).</dd>
</dl>
<dl>
<dt>replace</dt><dd><code>replace!(new_item container)</code> returns a container where each item is replaced with new_item. O(N).</dd>
<dt>replace_item</dt><dd><code>replace_item!(old_item new_item container)</code> returns a container with occurances of old_item replaced with new_item. O(N).</dd>
<dt>replace_if</dt><dd><code>replace_if!(predicate new_item container)</code> returns a container where each item is replaced if the predicate says <code>yes</code>. O(N).</dd>
</dl>
<dl>
<dt>count</dt><dd><code>count!container</code> returns the number of items in the container. O(N).</dd>
<dt>count_item</dt><dd><code>count!(item container)</code> counts the number of occurances of an item in the container. O(N).</dd>
<dt>count_if</dt><dd><code>count_if!(predicate container)</code> counts the number of items for which the predicate says <code>yes</code>. O(N).</dd>
</dl>

<h2>Generic Container Functions - Accessing Items</h2>
You can access the items of a container via <code>take!container</code> and <code>drop!container</code> and <code>container!index</code>, or using the following functions:
<dl>
<dt>get0</dt><dd><code>get0!container</code> returns the item with index 0 in the container. O(1).</dd>
<dt>get1</dt><dd><code>get1!container</code> returns the item with index 1 in the container. O(1).</dd>
<dt>get2</dt><dd><code>get2!container</code> returns the item with index 2 in the container. O(1).</dd>
<dt>get3</dt><dd><code>get3!container</code> returns the item with index 3 in the container. O(1).</dd>
<dt>get4</dt><dd><code>get4!container</code> returns the item with index 4 in the container. O(1).</dd>
<dt>get5</dt><dd><code>get5!container</code> returns the item with index 5 in the container. O(1).</dd>
<dt>get6</dt><dd><code>get6!container</code> returns the item with index 6 in the container. O(1).</dd>
<dt>get7</dt><dd><code>get7!container</code> returns the item with index 7 in the container. O(1).</dd>
<dt>get8</dt><dd><code>get8!container</code> returns the item with index 8 in the container. O(1).</dd>
<dt>get9</dt><dd><code>get9!container</code> returns the item with index 9 in the container. O(1).</dd>
</dl>
These fixed getters are useful in two situations. Firstly, for passing to a higher order function like <code>xs=map_stack!(get0 points)</code>. Secondly, when using multiple indices to index containers of containers like <code>scalar=get3!get2!matrix</code>. Otherwise, the easiest option is <code>container!index</code>, which works well in most other situations.

<h2>Specialized Container Functions</h2>
For the following functions you need to know what kind of container you want to use:
<dl>
<dt>make_stack</dt><dd><code>make_stack!container</code> copies the items in the container to a new stack. O(N).</dd>
<dt>make_string</dt><dd><code>make_string!container</code> copies the items in the container to a new string. O(N).</dd>
<dt>make_table</dt><dd><code>make_table!container</code> copies the items in the container to a new table. The container should contain tuples of <code>(key value)</code>. O(N).</dd>
</dl>
<dl>
<dt>merge_stack</dt><dd><code>merge_stack![c1 ... cn]</code> concatenates a stack of containers into a single stack. O(N).</dd>
<dt>merge_string</dt><dd><code>merge_string![c1 ... cn]</code> concatenates a stack of containers into a single string. O(N).</dd>
<dt>merge_table</dt><dd><code>merge_table![c1 ... cn]</code> merges a stack of containers into a single table. O(N).</dd>
</dl>
<dl>
<dt>map_stack</dt><dd><code>map_stack!(f container)</code> returns a stack with the function f applied to each item in the container. O(N).</dd>
<dt>map_string</dt><dd><code>map_string!(f container)</code> returns a string with the function f applied to each item in the container. O(N).</dd>
<dt>map_table</dt><dd><code>map_table!(f container)</code> returns a table with the function f applied to each item in the container. The function f should return a tuple <code>(key value)</code>. O(N).</dd>
</dl>
<dl>
<dt>range</dt><dd><code>range!n</code> returns the stack <code>[0 1 2 ... n-1]</code>.  O(n).</dd>
<dt>enumerate</dt><dd><code>enumerate![7 9 4]</code> returns the stack of tuples <code>[(0 7) (1 9) (2 4)]</code>, where the first item in each tuple is its index. O(N).</dd>
<dt>zip2</dt><dd><code>zip2!([1 2 3] [4 5 6])</code> returns the stack of tuples <code>[(1 4) (2 5) (3 6)]</code>, where each inner tuple combines the corresponding items from the input tuple of stacks. O(N).</dd>
<dt>zip3</dt><dd><code>zip3!([1 2 3] [4 5 6] [7 8 9])</code> returns the stack of tuples <code>[(1 4 7) (2 5 8) (3 6 9)]</code>, where each inner tuple combines the corresponding items from the input tuple of stacks. O(N).</dd>
<dt>zip4</dt><dd><code>zip4!([1 2] [3 4] [5 6] [7 8])</code> returns the stack of tuples <code>[(1 3 5 7) (2 4 6 8)]</code>, where each inner tuple combines the corresponding items from the input tuple of stacks. O(N).</dd>
<dt>split</dt><dd><code>split!(' ' "hey hey, ok")</code> returns <code>["hey" "hey," "ok"]</code> and <code>split!(1 [1 2 3 1 1 4])</code> returns <code>[[] [2 3] [] [4]]</code>. O(N).</dd>
<dt>cartesian_product2</dt><dd><code>cartesian_product2!([0 1] "ab")</code> returns the stack of tuples <code>[(1 'b') (0 'b') (1 'a') (0 'a')]</code>. O(MN).</dd>
<dt>put_column</dt><dd><code>put_column!([1 2] [[3] [4]])</code> returns <code>[[1 3] [2 4]]</code>. O(N).</dd>
<dt>transpose</dt><dd><code>transpose![[1 2] [3 4]]</code> returns <code>[[1 3] [2 4]]</code>. O(NM).</dd>
</dl>

<h2>Table Functions</h2>
<dl>
<dt>get</dt><dd><code>get!(key table default_value)</code> returns the value corresponding to the key in the table, if it exists, otherwise default_value is returned. O(log N).</dd>
<dt>put</dt><dd><code>put!((key value) table)</code> set the value corresponding to the key in the table and returns the table. Note that the table is also mutated so that other references to it are effected as well. O(log N).</dd>
<dt>get_keys</dt><dd><code>get_keys!table</code> returns a stack of all keys in the table. O(N).</dd>
<dt>get_values</dt><dd><code>get_values!table</code> returns a stack of all values in the table. O(N).</dd>
<dt>get_items</dt><dd><code>get_items!table</code> returns a stack of tuples, of all pairwise keys and values in the table. O(N).</dd>
<dt>count_elements</dt><dd><code>count_elements!container</code> returns a table where the keys are elements from the input container and the values are the number of times they occur in the input container. O(N log N).</dd>
<dt>unique</dt><dd><code>unique!container</code> returns a stack with the unique elements of the input container. O(N log N).</dd>
</dl>

<h2>Boolean Functions</h2>
<dl>
<dt>boolean</dt><dd>Convert a value to a boolean. All values are converted to <code>yes</code>, except empty stack <code>[]</code> and empty string <code>""</code> and number zero <code>0</code> and the boolean <code>no</code> which are all converted to <code>no</code>.</dd>
<dt>not</dt><dd>Convert a value to a boolean. All values are converted to <code>no</code>, except empty stack <code>[]</code> and empty string <code>""</code> and number zero <code>0</code> and the boolean <code>no</code> which are all converted to <code>yes</code>.</dd>
<dt>all / and</dt><dd>Takes a stack of booleans and returns <code>yes</code> if all items are <code>yes</code> and otherwise <code>no</code>.</dd>
<dt>any / or</dt><dd>Takes a stack of booleans and returns <code>yes</code> if any item is <code>yes</code> and otherwise <code>no</code>.</dd>
<dt>none</dt><dd>Takes a stack of booleans and returns <code>yes</code> if all item are <code>no</code> and otherwise <code>yes</code>.</dd>
<dt>equal</dt><dd>Takes two values and returns <code>yes</code> if they are equal and otherwise <code>no</code>.</dd>
<dt>unequal</dt><dd>Takes two values and returns <code>no</code> if they are equal and otherwise <code>yes</code>.</dd>
</dl>

<h2>Functions on Single Numbers</h2>
<dl>
<dt>inc</dt><dd>Increments a number by adding 1 to it.</dd>
<dt>dec</dt><dd>Decrements a number by subtracting 1 from it.</dd>
<dt>neg</dt><dd>Negates a number.</dd>
<dt>abs</dt><dd>Absolute value of a number.</dd>
<dt>round</dt><dd>Round a number to closest integer.</dd>
<dt>round_up</dt><dd>Round a number up to closest integer.</dd>
<dt>round_down</dt><dd>Round a number down to closest integer.</dd>
<dt>sqrt</dt><dd>Square root of a number.</dd>
</dl>

<h2>Functions on Pairs of Numbers</h2>
<dl>
<dt>add</dt><dd>Add a tuple of two numbers.</dd>
<dt>mul</dt><dd>Multiply a tuple of two numbers.</dd>
<dt>sub</dt><dd>Subtract a tuple of two numbers.</dd>
<dt>div</dt><dd>Divide a tuple of two numbers.</dd>
<dt>min</dt><dd>Minimum of a tuple of two numbers.</dd>
<dt>max</dt><dd>Maximum of a tuple of two numbers.</dd>
<dt>less</dt><dd>Takes a tuple of two numbers and returns <code>yes</code> if the first is smaller than the second, otherwise <code>no</code>.</dd>
<dt>less_or_equal</dt><dd>Takes a tuple of two numbers and returns <code>yes</code> if the first is smaller or equal to the second, otherwise <code>no</code>.</dd>
<dt>greater</dt><dd>Takes a tuple of two numbers and returns <code>yes</code> if the first is larger than the second, otherwise <code>no</code>.</dd>
</dl>

<h2>Functions on Stacks of Numbers</h2>
<dl>
<dt>sum</dt><dd>Adds a stack of numbers to a single number. Returns <code>0</code> if the stack is empty.</dd>
<dt>product</dt><dd>Multiplies a stack of numbers to a single number. Returns <code>1</code> if the stack is empty.</dd>
<dt>min_item</dt><dd>Minimum of a stack of numbers. Returns <code>inf</code> if the stack is empty.</dd>
<dt>max_item</dt><dd>Maximum of a stack of numbers. Returns <code>-inf</code> if the stack is empty.</dd>
<dt>min_key</dt><dd><code>min_key!(key stack)</code> returns the item in the stack for which the the result of the function application <code>key!item</code> is smallest. Requires the stack to be non-empty.</dd>
<dt>max_key</dt><dd><code>max_key!(key stack)</code> returns the item in the stack for which the result of the function application <code>key!item</code> is largest. Requires the stack to be non-empty..</dd>
<dt>min_predicate</dt><dd> <code>min_predicate!(predicate stack)</code> compares all items in the stack and returns the item that is smallest according to the binary predicate. <code>predicate!(left right)</code> checks if left is smaller than right and returns a boolean. Requires the stack to be non-empty.</dd>
<dt>max_predicate</dt><dd> <code>max_predicate!(predicate stack)</code> compares all items in the stack and returns the item that is largest according to the binary predicate. <code>predicate!(left right)</code> checks if left is smaller than right and returns a boolean. Requires the stack to be non-empty.</dd>
</dl>

<h2>Character Functions</h2>
<dl>
<dt>number</dt><dd>Takes a character and returns its ascii number.</dd>
<dt>character</dt><dd>Takes a number and returns the character with that ascii number.</dd>
<dt>parse_digit</dt><dd>Takes a character and returns the corresponding number.</dd>
<dt>parse_natural_number</dt><dd>Takes a string and returns the corresponding non-negative integer.</dd>
<dt>is_digit</dt><dd>Is a character a digit? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>is_letter</dt><dd>Is a character a letter? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>is_upper</dt><dd>Is a character upper case? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>is_lower</dt><dd>Is a character lower case? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>to_upper</dt><dd>Takes a character and converts it to upper case. Only has an effect it the character is a lower case letter.</dd>
<dt>to_lower</dt><dd>Takes a character and converts it to lower case. Only has an effect it the character is an upper case letter.</dd>
</dl>

</body>
</html>
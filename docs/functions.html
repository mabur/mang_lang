<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mali">
<link rel="stylesheet" href="styles.css">
<title>Manglang Functions</title>
</head>
<body>

<h1>Functions</h1>

<p>
Below you can find all functions included with Manglang. They are either built-in or implemented in the
<a href="https://github.com/mabur/mang_lang/blob/master/mang_lang_cpp/built_in_functions/standard_library.h">standard library</a>.
</p>

<h2>Time Complexity</h2>
<p>
For all container functions we specify how the time complexity depends on the number of elements N in the container. So an operation that is marked as O(1) takes the same time for small and large containers. An operation that is marked as O(N) takes twice as long for a container that is twice as big.
</p>

<h2>Container Interface</h2>
Manglang has containers like: stacks, strings, tables. They share an interface of basic operations:
<dl>
<dt>take</dt><dd><code>take!container</code> returns a single item from the container. O(1).</dd>
<dt>drop</dt><dd><code>drop!container</code> returns the container with a single item dropped from it. O(1).</dd>
<dt>put</dt><dd><code>put!(item container)</code> returns a new container with item added to the old container. For tables we have that <code>put!((key value) table)</code> sets the value corresponding to the key in the table and returns the table. For stacks and strings the original container is not mutated, but it is mutated for tables so that other references to it are effected as well! O(1).</dd>
<dt>clear</dt><dd><code>clear!container</code> returns an empty container of the same type as the input. O(1).</dd>
</dl>
The relationship of these functions can be expressed as <code>put!(take!container drop!container)</code> gives back just the <code>container</code>. Furthermore, we check if a container is not empty by <code>if container then ... else ...</code> O(1).

<p>
The operations can be used as a base for building more container functions. The standard library does that and adds all the functions below.
</p>

<h2>Generic Container Functions</h2>
These functions work on both stacks, strings, tables, and the type of the output container is the same as the input.
We use the word container to represent either a stack, string or table.
<dl>
<dt>put_each</dt><dd><code>put_each!(top_container bottom_container)</code> returns a new container with each item from the top_container put on top of the bottom_container,
such that the bottom of the top_container is the new top item.
As an example <code>put_each!([1 2 3] [4 5 6])</code> returns <code>[3 2 1 4 5 6]</code> and <code>put_each!("abc" "def")</code> returns <code>"cbadef"</code>.
So the order of the top_stack gets reversed as it is put on the new stack.
For tables we have that <code>put_each!(<1:1 2:1 3:1> <5:2 2:2 4:2>)</code> returns <code><1:1 2:1 3:1 4:2 5:2></code>, so the keys are sorted and if we have duplicated keys then value from the top container over-writes the value from the bottom container. O(N+M).
</dd>
<dt>reverse</dt><dd><code>reverse!container</code> returns a container with the items in the reverse order for stacks and string. For tables we just get a copy, since a table is always sorted by its keys. O(N).</dd>
<dt>fold</dt><dd><code>fold!(binary_operation container init)</code> is mainly used as an algorithmic building block to implement the other container functions. O(N).</dd>
</dl>

<h2>Generic Container Functions</h2>
<dl>
<dt>clear</dt><dd><code>clear!container</code> returns an empty container of the same type as the input. O(1).</dd>
<dt>clear_item</dt><dd><code>clear_item!(item container)</code> returns a container with all occurances of the specified item removed. O(N).</dd>
<dt>clear_if</dt><dd><code>clear_if!(predicate container)</code> returns a container without the items for which the predicate says <code>yes</code>. O(N).</dd>
</dl>
<dl>
<dt>drop</dt><dd><code>drop!container</code> returns the container with a single item dropped from it. O(1).</dd>
<dt>drop_many</dt><dd><code>drop_many!(n container)</code> returns the container with n items dropped from it. O(n).</dd>
<dt>drop_while</dt><dd><code>drop_while!(predicate container)</code> returns the container with items dropped from it as long as the predicate says yes. O(N).</dd>
<dt>drop_until_item</dt><dd><code>drop_until_item!(item container)</code> returns a container with items dropped until the query item is found. O(N).</dd>
</dl>
<dl>
<dt>take</dt><dd><code>take!container</code> returns a single item from the container. O(1).</dd>
<dt>take_many</dt><dd><code>take_many!(n container)</code> returns a new containers with n items taken from the input container. O(n).</dd>
<dt>take_while</dt><dd><code>take_while!(predicate container)</code> returns a new containers with items taken from the input container as long as the predicate says yes. O(N).</dd>
<dt>take_until_item</dt><dd><code>take_until_item!(item container)</code> returns a new containers with items taken from the input container until the query item is found. O(N).</dd>
</dl>
<dl>
<dt>replace</dt><dd><code>replace!(new_item container)</code> returns a container where each item is replaced with new_item. O(N).</dd>
<dt>replace_item</dt><dd><code>replace_item!(old_item new_item container)</code> returns a container with occurances of old_item replaced with new_item. O(N).</dd>
<dt>replace_if</dt><dd><code>replace_if!(predicate new_item container)</code> returns a container where each item is replaced if the predicate says <code>yes</code>. O(N).</dd>
</dl>
<dl>
<dt>count</dt><dd><code>count!container</code> returns the number of items in the container. O(N).</dd>
<dt>count_item</dt><dd><code>count!(item container)</code> counts the number of occurances of an item in the container. O(N).</dd>
<dt>count_if</dt><dd><code>count_if!(predicate container)</code> counts the number of items for which the predicate says <code>yes</code>. O(N).</dd>
</dl>

<h2>Generic Container Functions - Accessing Items</h2>
You can access the items of a container via <code>take!container</code> and <code>drop!container</code>, or using the following functions:
<dl>
<dt>split</dt><dd><code>split!(n container)</code> O(n).</dd>
<dt>get_index</dt><dd><code>get_index!(n container)</code> returns the nth item in the container. O(n).</dd>
<dt>first</dt><dd><code>first!container</code> returns the first item in the container. O(1).</dd>
<dt>second</dt><dd><code>second!container</code> returns the second item in the container. O(1).</dd>
<dt>third</dt><dd><code>third!container</code> returns the third item in the container. O(1).</dd>
<dt>fourth</dt><dd><code>fourth!container</code> returns the fourth item in the container. O(1).</dd>
<dt>fifth</dt><dd><code>fifth!container</code> returns the fifth item in the container. O(1).</dd>
<dt>sixth</dt><dd><code>sixth!container</code> returns the sixth item in the container. O(1).</dd>
<dt>seventh</dt><dd><code>seventh!container</code> returns the seventh item in the container. O(1).</dd>
<dt>eighth</dt><dd><code>eighth!container</code> returns the eighth item in the container. O(1).</dd>
<dt>ninth</dt><dd><code>ninth!container</code> returns the ninth item in the container. O(1).</dd>
<dt>tenth</dt><dd><code>tenth!container</code> returns the tenth item in the container. O(1).</dd>
</dl>

<h2>Specialized Container Functions</h2>
For the following functions you need to know what kind of container you want to use:
<dl>
<dt>make_stack</dt><dd><code>make_stack!container</code> copies the items in the container to a new stack. O(N).</dd>
<dt>make_string</dt><dd><code>make_string!container</code> copies the items in the container to a new string. O(N).</dd>
<dt>make_table</dt><dd><code>make_table!container</code> copies the items in the container to a new table. The container should contain tuples of <code>(key value)</code>. O(N).</dd>
</dl>
<dl>
<dt>merge_stack</dt><dd><code>merge_stack![c1 ... cn]</code> concatenates a stack of containers into a single stack. O(N).</dd>
<dt>merge_string</dt><dd><code>merge_string![c1 ... cn]</code> concatenates a stack of containers into a single string. O(N).</dd>
<dt>merge_table</dt><dd><code>merge_table![c1 ... cn]</code> merges a stack of containers into a single table. O(N).</dd>
</dl>
<dl>
<dt>map_stack</dt><dd><code>map_stack!(f container)</code> returns a stack with the function f applied to each item in the container. O(N).</dd>
<dt>map_string</dt><dd><code>map_string!(f container)</code> returns a string with the function f applied to each item in the container. O(N).</dd>
<dt>map_table</dt><dd><code>map_table!(f container)</code> returns a table with the function f applied to each item in the container. The function f should return a tuple <code>(key value)</code>. O(N).</dd>
</dl>
<dl>
<dt>range</dt><dd><code>range!n</code> returns the stack <code>[0 1 2 ... n-1]</code>.  O(n).</dd>
<dt>enumerate</dt><dd><code>enumerate![7 9 4]</code> returns the stack of tuples <code>[(0 7) (1 9) (2 4)]</code>, where the first item in each tuple is its index. O(N).</dd>
<dt>zip</dt><dd><code>zip!([1 2 3] [4 5 6])</code> returns the stack of tuples <code>[(1 4) (2 5) (3 6)]</code>, where each inner tuple combines the corresponding items from the input tuple of stacks.</dd>
</dl>

<h2>Table Functions</h2>
<dl>
<dt>get</dt><dd><code>get!(key table default_value)</code> returns the value corresponding to the key in the table, if it exists, otherwise default_value is returned.</dd>
<dt>put</dt><dd><code>put!((key value) table)</code> set the value corresponding to the key in the table and returns the table. Note that the table is also mutated so that other references to it are effected as well.</dd>
<dt>get_keys</dt><dd><code>get_keys!table</code> returns a stack of all keys in the table.</dd>
<dt>get_values</dt><dd><code>get_values!table</code> returns a stack of all values in the table.</dd>
<dt>get_items</dt><dd><code>get_items!table</code> returns a stack of tuples, of all pairwise keys and values in the table.</dd>
</dl>

<h2>Boolean Functions</h2>
<dl>
<dt>boolean</dt><dd>Convert a value to a boolean. All values are converted to <code>yes</code>, except empty stack <code>[]</code> and empty string <code>""</code> and number zero <code>0</code> and the boolean <code>no</code> which are all converted to <code>no</code>.</dd>
<dt>not</dt><dd>Convert a value to a boolean. All values are converted to <code>no</code>, except empty stack <code>[]</code> and empty string <code>""</code> and number zero <code>0</code> and the boolean <code>no</code> which are all converted to <code>yes</code>.</dd>
<dt>all</dt><dd>Takes a stack of booleans and returns <code>yes</code> if all items are <code>yes</code> and otherwise <code>no</code>.</dd>
<dt>any</dt><dd>Takes a stack of booleans and returns <code>yes</code> if any item is <code>yes</code> and otherwise <code>no</code>.</dd>
<dt>none</dt><dd>Takes a stack of booleans and returns <code>yes</code> if all item are <code>no</code> and otherwise <code>yes</code>.</dd>
<dt>equal</dt><dd>Takes two values and returns <code>yes</code> if they are equal and otherwise <code>no</code>.</dd>
<dt>unequal</dt><dd>Takes two values and returns <code>no</code> if they are equal and otherwise <code>yes</code>.</dd>
</dl>

<h2>Functions on Multiple Numbers</h2>
<dl>
<dt>add</dt><dd>Add a tuple of two numbers.</dd>
<dt>mul</dt><dd>Multiply a tuple of two numbers.</dd>
<dt>sub</dt><dd>Subtract a tuple of two numbers.</dd>
<dt>div</dt><dd>Divide a tuple of two numbers.</dd>
<dt>min</dt><dd>Minimum of a stack of numbers.</dd>
<dt>max</dt><dd>Maximum of a stack of numbers</dd>
<dt>less</dt><dd>Takes a tuple of two numbers and returns <code>yes</code> if the first is smaller than the second, otherwise <code>no</code></dd>
<dt>greater</dt><dd>Takes a tuple of two numbers and returns <code>yes</code> if the first is larger than the second, otherwise <code>no</code></dd>
</dl>

<h2>Functions on Single Numbers</h2>
<dl>
<dt>inc</dt><dd>Increments a number by adding 1 to it.</dd>
<dt>dec</dt><dd>Decrements a number by subtracting 1 from it.</dd>
<dt>neg</dt><dd>Negates a number.</dd>
<dt>abs</dt><dd>Absolute value of a number.</dd>
<dt>round</dt><dd>Round a number to closest integer.</dd>
<dt>round_up</dt><dd>Round a number up to closest integer.</dd>
<dt>round_down</dt><dd>Round a number down to closest integer.</dd>
<dt>sqrt</dt><dd>Square root of a number.</dd>
</dl>

<h2>Character Functions</h2>
<dl>
<dt>number</dt><dd>Takes a character and returns its ascii number.</dd>
<dt>character</dt><dd>Takes a number and returns the character with that ascii number.</dd>
<dt>parse_digit</dt><dd>Takes a character and returns the corresponding number.</dd>
<dt>is_digit</dt><dd>Is a character a digit? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>is_letter</dt><dd>Is a character a letter? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>is_upper</dt><dd>Is a character upper case? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>is_lower</dt><dd>Is a character lower case? Returns <code>yes</code> or <code>no</code>.</dd>
<dt>to_upper</dt><dd>Takes a character and converts it to upper case. Only has an effect it the character is a lower case letter.</dd>
<dt>to_lower</dt><dd>Takes a character and converts it to lower case. Only has an effect it the character is an upper case letter.</dd>
</dl>

</body>
</html>
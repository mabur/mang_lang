<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mali">
<link rel="stylesheet" href="styles.css">
<title>Manglang</title>
</head>
<body>


<table width=100%>
<tr>
    <td>
    </td>
    <td>
    </td>
    <td align=center>
        <q>Functional programming made simple</q>
        <br>
        <img class="character" src="c6.png">
    </td>
    <td>
    </td>
    <td>
    </td>
</tr>
<tr>
    <td align=right>
        <q>Minimal instead of feature rich</q>
    </td>
    <td>
        <img class="character" src="c5.png">
    </td>
    <td>
    </td>
    <td align=right>
        <img class="character" src="c4.png">
    </td>
    <td>
        <q>Programmable json</q>
    </td>
</tr>
<tr>
    <td align=right>
        <q>Easy to understand, for both humans &amp; computers</q>
    </td>
    <td>
        <img class="character" src="c2.png">
    </td>
    <td>
    </td>
    <td align=right>
        <img class="character" src="c1.png">
    </td>
    <td>
        <q>Suitable for data &amp; calculations, but not interactive programs with side effects</q>
    </td>
</tr>
<tr>
    <td>
    </td>
    <td>
    </td>
    <td align=center>
        <img class="character" src="c3.png"><br>
        <q>Functional &amp; imperative &amp; generic programming</q>
    </td>
    <td>
    </td>
    <td>
    </td>
</tr>
</table>

<h1>Manglang</h1>
<p>
Manglang is an <b>experimental</b> programming language that is <b>simple</b> and <b>minimal</b>.
It is suitable for describing data and calculations, but not interactive programs with side effects. Manglang code can either be evaluated using its stand-alone interpreter or be embedded as a scripting language within C++.
</p>

<h1>Code Evaluation</h1>
<p>
Manglang is a functional and interpreted language.
It takes source code written in Manglang and evaluates it.
Consider the following input program:
</p>
<pre>
{
  rectangles = [
    {width = 3 height = 1}
    {width = 6 height = 2}
    {width = 3 height = 6}
    {width = 8 height = 4}
  ]
  get_area = in {width height}
    out mul!(width height)
  areas = map!(get_area rectangles)
  total_area = add!areas
  num_rectangles = count!rectangles
  average_area = div!(total_area num_rectangles)
}
</pre>

<p>
When we evaluate the input above we get the output below:
</p>
<pre>
{
  rectangles = [
    {width = 3 height = 1}
    {width = 6 height = 2}
    {width = 3 height = 6}
    {width = 8 height = 4}
  ]
  get_area = in {width height}
    out mul!(width height)
  areas = [3 12 18 32]
  total_area = 65
  num_rectangles = 4
  average_area = 16.25
}
</pre>
<p>
Note that both the input and output of the Manglang interpreter is given as Manglang code!
The Manglang format can be used to both write programs and to express pure data.
It can for instance be used as a programmable configuration language.
</p>
<p>
For more code examples continue reading below, or look inside the
<a href="https://github.com/mabur/mang_lang/blob/master/mang_lang_cpp/built_in_functions/standard_library.h">standard library</a>. There is also <a href="functions.html">documentation for all functions</a>.
</p>

<h1>Building Blocks</h1>
<p>
Manglang consists of the following basic building blocks:
</p>
<table>
<tr>
<td>
<img src="atom.png" width=48 height=48>
</td>
<td>
<a href="#atoms">Atoms</a> like <a href="#numbers">numbers</a> and <a href="#characters">characters</a> and <a href="#booleans">booleans</a>.
</td>
</tr>
<tr>
<td>
<img src="container2.png" width=48 height=48>
</td>
<td>
<a href="#containers">Containers</a> holding data like <a href="#dictionaries">dictionaries</a>, <a href="#tuples">tuples</a> , <a href="#stacks">stacks</a> and <a href="#strings">strings</a>.
</td>
</tr>
<tr>
<td>
<img src="control_flow.png" width=48 height=48>
</td>
<td>
<a href="#control_flow">Control flow</a> like <a href="#if">if</a>,  <a href="#is">is</a> and <a href="#while">while</a>.
</td>
</tr>
<tr>
<td>
<img src="function.png" width=48 height=48>
</td>
<td>
<a href="#function_definition">Function definitions</a> and <a href="#function_application">function applications</a> which transform data.
</td>
</tr>
</table>
<p>
Below you will find descriptions and examples of each of these language constructs.
</p>

<h1 id="atoms">1. Atoms<img src="atom.png" width=48 height=48></h1>
<p>
Manglang has three kinds of atomic or primitive data: numbers, characters and booleans.
</p>

<h2 id="numbers">1.a. Numbers</h2>
<p>
Manglang has a single number type which is a 64 bit float:
</p>
<pre>
12.34
</pre>

<h2 id="characters">1.b. Characters</h2>
<p>
A single ascii character is written with <code>\</code> as prefix:
</p>
<pre>
\a
</pre>

<h2 id="booleans">1.c. Booleans</h2>
<p>
A boolean is either:
<pre>
yes
</pre>
or
<pre>
no
</pre>
</p>
In Manglang we see booleans as answers to questions and therefore write them as <code>yes</code> and <code>no</code> instead of <code>true</code> and <code>false</code>. This is closer to natural language and also shorter.

<h1 id="containers">2. Containers<img src="container2.png" width=48 height=48></h1>
<p>
Manglang has three different kinds of containers which can store other data inside them: dictionaries, stacks and strings.
</p>

<h2 id="dictionaries">2.a. Dictionaries</h2>
<p>
Dictionaries are used to associate names / symbols with expressions:
</p>
<pre>
{pi=3.14 first_letter=\A}
</pre>
<p>
Manglang doesn't care about extra whitespace so the program above can also be written as:
</p>
<pre>
{
  pi = 1
  first_letter = \A
}
</pre>
<p>
Dictionaries can be nested:
</p>
<pre>
{
  rectangle = {width = 4 height = 5}
  circle = {radius = 5}
}
</pre>

<h3 id="reference">Reference to Current Dictionary</h2>
<p>
A name defined in a dictionary can be referenced after it is defined:
</p>
<pre>
{
  a = 1
  b = a
}
</pre>
<p>
The input above is evaluated to the output below:
</p>
<pre>
{
  a = 1
  b = 1
}
</pre>
<h3 id="reference">Reference to Outer Dictionaries</h2>
<p>
Dictionaries can be nested. You can also refer to a name in an outer dictionary:
</p>
<pre>
{
  a = 1
  b = {c = 2 d = a}
}
</pre>
<p>
The input above is evaluated to the output below:
</p>
<pre>
{
  a = 1
  b = {c = 2 d = 1}
}
</pre>
<p>
When refering to a name the current dictionary is first checked and then the next outer dictionary and so on.
</p>

<h3 id="child_reference">Reference to Inner Dictionary</h2>
<p>
You can refer to names in an inner dictionary like this:
</p>
<pre>
{
  a = {b=2 c=3}
  d = b@a
}
</pre>
<p>
The input above is evaluated to the output below:
</p>
<pre>
{
  a = {b=2 c=3}
  d = 2
}
</pre>
<p>
The syntax <code>name@dictionary</code> is used to get the value corresponding to the name/key inside the dictionary.
This syntax is reversed compared to most languages that instead write this as <code>dictionary.name</code>.
However, having it like this simplifies the syntax of Manglang and makes it easier to parse.
It also makes both function application and dictionary lookup follow the same order and pattern. 
</p>

<h3>Dictionaries everywhere</h3>
<p>
In Manglang dictionaries are the only way to associate names / symbols with expressions.
So Manglang uses dictionaries to represent both:
<ul>
<li>Variables</li>
<li>Objects</li>
<li>Function input</li>
<li>Function output</li>
</ul>
In the next sections we will look at the remaining three containers in Manglang:
<ul>
<li>Tuples</li>
<li>Stacks</li>
<li>Strings</li>
</ul>
We will see that each of them can be seen as syntactic sugar sprinkled on dictionaries.
</p>

<h2 id="tuples">2.b. Tuples</h2>
<p>Tuples of values are written as:</p>
<pre>
(3 17.5 yes \A)
</pre>
<p>
We use tuples to group different atomics as an ordered list. The elements of the tuple can have different types, just as the elements of a dictionary can have different types. To see the similarity consider this example:
</p>
<pre>
{
  tuple = (3 17.5 yes \A)
  dictionary = {first=3 second=17.5 third=yes fourth=\A}
}
</pre>
These are two different ways of storing the same data.
Tuples in Manglang can be seen as syntactic sugar sprinkled on dictionaries so that we can use the first more concise notation instead of the second more verbose notation.
Conceptually we can think of a tuple as a dictionary having the members <code>first, second, third, ...</code>,
and we can access the data in the tuple as if it was such a dictionary via <code>first@tuple</code> etc. A common use case for tuples is to send multiple inputs of different types to a function.

<h2 id="stacks">2.c. Stacks</h2>
<p>Stacks of values are written as:</p>
<pre>
[3 6 4]
</pre>
A stack can be seen as a dictionary containing two things <code>top</code> and <code>rest</code>.
Consider this example:
<pre>
{
  stack = [3 6 4]
  dictionary = {top=3 rest={top=6 rest={top=4 rest={}}}}
}
</pre>
<p>
These are two different ways of storing the same data.
Stacks in Manglang can be seen as syntactic sugar sprinkled on dictionaries so that we can use the first more concise notation instead of the second more verbose notation.
Conceptually we can think of a stack as a dictionary having the members <code>top</code> and <code>rest</code>,
and we access the data in the stack as if it was such a dictionary via <code>top@stack</code> and <code>rest@stack</code>. There are two differences between tuples and stacks:
<ul>
<li>All elements of a stack should have the same type.</li>
<li>We can generate a new stack from base stack by adding or removing elements from it.</li>
</ul>
</p>
<p>
If we have a <code>stack</code> we can the stack with all elements except the first via <code>rest@stack</code>. The function <code>put</code> is used to construct a new stack by putting a new item on top of the stack:
</p>
<pre>
put!(7 [4 5 2])
</pre>
The input above is evaluated to the output below:
<pre>
[7 4 5 2]
</pre>
<p>Here is another example program with some stack operations:</p>
<pre>
{
  a = [3 6 4]
  b = top@a
  c = rest@a
  d = put!(b c) 
}
</pre>
<p>The input above is evaluated to the output below:</p>
<pre>
{
  a = [3 6 4]
  b = 3
  c = [6 4]
  d = [3 6 4]
}
</pre>
In summary, we interact with stacks by accessing the members <code>top</code> and <code>rest</code> and via the function <code>put</code>. The standard library of Manglang provides more functions that works on stacks but they are all built on top of this basic interface.

<h2 id="strings">2.d. Strings</h2>
<p>
Strings are written as:
</p>
<pre>
"Manglang"
</pre>
<p>
They can be seen as stacks of characters. Example of a program using functions on strings:
</p>
<pre>
{
  a = "Manglang"
  b = top@a
  c = rest@a
  d = reverse!a
  e = put!(\E a)
}
</pre>
The input above is evaluated to the output below:
<pre>
{
  a = "Manglang"
  b = \M
  c = "anglang"
  d = "gnalgnaM"
  e = "EManglang"
}
</pre>

<h1 id="control_flow">4. Control Flow <img src="control_flow.png" width=48 height=48></h1>

<h2 id="if">4.a. If</h2>
<p>
The expression <code>if a then b else c</code> is evaluated to b or c depending on if the answer to the question a is yes or no.
<ul>
<li>
The following values are interpreted as <code>no</code> or falsey:
    <ul>
        <li>boolean <code>no</code></li>
        <li>number zero <code>0</code></li>
        <li>empty stack <code>[]</code></li>
        <li>empty string <code>""</code> </li>
    </ul>
</li>
<li>
All other values are interpreted as <code>yes</code> or truthy.
</li>
</ul>
Consider this example:
</p>
<pre>
{
  a = [0 1]
  b = if a then
      top@a
    else
      2
  c = if b then "hello" else "world"
}
</pre>
<p>
This program is evaluated to:
</p>
<pre>
{
  a = [0 1]
  b = 0
  c = "world"
}
</pre>

<h2 id="is">4.b. Is</h2>
<p>
The <code>is</code> operator is used to check for equality among many alternatives. It is similar to switch-case or pattern matching in other languages. Consider this example where we use the is operator to find the corresponding characters:
</p>
<pre>
{
  opening = \{
  closing = is opening
    \( then \)
    \[ then \]
    \{ then \}
    \< then \>
    else  \.
}
</pre>
The input above is evaluated to the output below:
<pre>
{
  opening = \{
  closing = \}
}
</pre>
The <code>is</code> operator can be seen as syntactic sugar for a more verbose combination of the <code>if</code> operator and the <code>equal</code> function:
<pre>
{
  opening = \{
  closing = if equal?(opening \() then \)
    else if equal?(opening \{) then \}
    else if equal?(opening \[) then \]
    else if equal?(opening \<) then \>
    else \.
}
</pre>

<h2 id="while">4.c. While</h2>
<p>
In Manglang you can loop while constructing a dictionary:
</p>
<pre>
{
  x = 10
  tot = 0
  while x
    tot = add!(tot x)
    x = dec!x
  end
}
</pre>
The input above is evaluated to the output below:
<pre>
{
  x = 0
  tot = 55
}
</pre>
<p>
The loop decrements x until it is zero and then finishes.
Definitions in a dictionary can only be updated / mutated while the dictionary is constructed.
Once it has been constructed it is immutable and cannot be updated.
</p>

<h1 id="functions">5. Functions <img src="function.png" width=48 height=48></h1>

<h2 id="function_application">5.a. Function Application</h2>
<p>
We have already seen some examples of calling / applying functions in Manglang.
A function is called using <code>!</code> like <code>function_name!input</code>.
We see function application as a command and hence use the symbol <code>!</code> after the verb that names the functions.
Functions take a single value as input.
However, this single value can be a stack or tuple or dictionary, that has multiple values inside.
</p>
<pre>
{
  stack = [4 2 1]
  sum0 = sum!stack
  sum1 = sum![4 2 1]
  stack2 = put!(3 stack)
}
</pre>
<p>
This program is evaluated to:
</p>
<pre>
{
  stack = [4 2 1]
  sum0 = 7
  sum1 = 7
  stack2 = [3 4 2 1]
}
</pre>
<p>
Manglang does not have any special operators for arithmetics, boolean, stack operations etc.
Instead functions are used for all computations.
Function calls can be nested like this:
</p>
<pre>
mul!(add!(1 2) sub!(7 2))
</pre>
<p>
This program is evaluated to <code>(1+2)*(7-2) = 3*5 = 15</code>.
Function calls are right associative.
Manglang does not support currying.

<h3>Applying Predicates</h2>
Manglang encourages using <code>?</code> instead of <code>!</code> for applying functions that return a boolean value, a.k.a. predicates. Applying such a function is like asking a question. As an example consider the following functions from the standard library that operate on ascii characters:
<pre>
{
  is_upper = in c out less_or_equal?[65 number!c 90]
  is_lower = in c out less_or_equal?[97 number!c 122]
  to_upper = in c out
      if is_lower?c then
          character!sub!(number!c 32)
      else
          c
  to_lower = in c out
      if is_upper?c then
          character!add!(number!c 32)
      else
          c
}
</pre>
</p>

<h2 id="function_definition">5.b. Function Definition</h2>
<p>
Functions are defined using they keywords <code>in</code> and <code>out</code> like this:
</p>
<pre>
{
  square = in x out mul!(x x)
  result = square!3
}
</pre>
<p>
A function definition is on the form <code>in x out expression</code>
where x is the name of the input and expression is the output.
Functions are first class values and can be given a name by putting them inside a dictionary.
Here are some examples of defining and calling functions:
</p>
<pre>
{
  square = in x out mul!(x x)
  inc = in x out add!(x 1)
  dec = in x out sub!(x 1)
  count = in stack
    out
      if stack then
        inc!count!rest@stack
      else
        0
  a = square!3
  b = inc!3
  c = dec!3
  d = count![3 7 3 8 2]
  e = count!"apple"        
}
</pre>
<p>
This program is evaluated to:
</p>
<pre>
{
  square = in x out mul!(x x)
  inc = in x out add!(x 1)
  dec = in x out sub!(x 1)
  count = in stack
    out
      if stack then
        inc!count!rest@stack
      else
        0
  a = 9
  b = 4
  c = 2
  d = 5
  e = 5        
}
</pre>
<p>
The if-then-else operator is used to choose what value to return based on a condition.
Functions can be recursive like the <code>count</code> example above.
Function definitions and computations can be broken up into smaller parts by using dictionaries:
</p>
<pre>
{
  square = in x out mul!(x x)
  square_norm = in vec3 out result@{
    x = first@vec3
    y = second@vec3
    z = third@vec3
    result = add!(square!x square!y square!z)
  }
  vector = (3 4 5)
  result = square_norm!vector
}
</pre>

<h2 id="function_tuple_definition">5.c. Function of Tuple Definition</h2>
<p>
Manglang provides syntactic sugar for defining functions that take multiple input,
in the form of a tuple.
Here are some examples of equivalent ways of defining and calling functions: 
</p>
<pre>
{
  area1 = in rectangle out mul!(first@rectangle second@rectangle)
  area2 = in (width height) out mul!(width height)
  rectangle = (5 4)
  a = area1!rectangle,
  b = area2!rectangle,
  c = area1!(5 4)
  d = area2!(5 4)
}
</pre>
<p>
The functions <code>area1</code> and <code>area2</code> are equivalent.
They expect the same input and return the same result.
<code>area2</code> just uses syntactic sugar to make its implementation more concise,
by unpacking the elements of the input tuple.
</p>


<h2 id="function_dictionary_definition">5.d. Function of Dictionary Definition</h2>

<p>
Manglang provides syntactic sugar for defining functions that take multiple input,
in the form of a dictionary with named entries.
Here are some examples of equivalent ways of defining and calling functions: 
</p>
<pre>
{
  area1 = in rectangle out mul!(width@rectangle height@rectangle)
  area2 = in {width height} out mul!(width height)
  rectangle = {width = 5 height = 4}
  a = area1!rectangle
  b = area2!rectangle
  c = area1!{width = 5 height = 4}
  d = area2!{width = 5 height = 4}
}
</pre>
<p>
The functions <code>area1</code> and <code>area2</code> are equivalent.
They expect the same input and return the same result.
<code>area2</code> just uses syntactic sugar to make it its implementation more concise,
by unpacking the elements of the input dictionary.
</p>

<h1>More Code Examples</h1>
<p>
For more code examples look inside the
<a href="https://github.com/mabur/mang_lang/blob/master/mang_lang_cpp/built_in_functions/standard_library.h">standard library</a>.
</p>

<h1>Function Documentation</h1>
<p>
Description of all <a href="functions.html">functions</a> that come with Manglang.
</p>

<h1>Setup</h1>

Manglang is implemented in C++. It is built from source using <code>mang_lang_cpp/CMakeLists.txt</code>, which produces the executable <code>interpreter</code>. 
You can then evaluate a program with the command <code>interpreter input_file_path output_file_path</code>, which takes the source code in <code>input_file_path</code> and evaluates it and writes the result to <code>output_file_path</code>. Manglang can also be embedded in another C++ program by including <code>mang_lang_cpp/mang_lang.h</code> and using the function <code>std::string evaluate(std::string code);</code>


</body>
</html>
TYPE SYSTEM
* Maybe types should not be re-evaluated for every function call?
  - Could store evaluted types if we have EvaluatedFunction structs.
    - So EvaluatedFunction sets both environment and types of arguments.
* Sort out sub-type relation and consistent relation.
  - a subtype can be used where the supertype is expected.
  - is & if alternatives should be consistent/equivalent.
    - Currently use else as base.
  - TypedExpression and function arguments are of on the form SuperType:SubType
    - Feels like it can be confusing for []
  - Both good and bad to use [] to represent both emtpy stack and stack of any item type.
    - Feels like sub-type relation can go both ways depending on perspective.
  - Subtype hierarchy or graph:
    - ANY
      - Character
      - Homogeneous & dynamic containers
        - Concept: take, drop.
          - Names: Sender (bra), Source, Consumable, Provider, Producer, Publisherl, InputIterator, Iterable, Reader.
          - Container
          - Text file input
          - Terminal input
          - Random number generation
          - Mouse input
          - Keyboard input
          - Concurrent input channel
        - Concept: put, clear?
          - Names: Receiver (bra), Target, Destination, Sink,
                   Accumulator, Aggregator, Consumer, Gatherer, Collector, Subscriber, OutputIterator, Writer.
          - Container
          - Text file output
          - Terminal output
          - TUI output
          - Concurrent output channel
          - Pixel output?
            - How to make it efficient for real-time 2d games and images?
            - Might need an array/range/slice type.
            - Could also hide it behind a built-in sprite abstraction. Good enough for 2D.
        - Container: take, drop, put, clear.
          - Boolean
          - Number
          - String
          - Generic Option/Optional/Maybe, Option[]
            - Concrete options, Option[...]
          - Generic stack, []
            - Concrete stacks, [...]
          - Generic table, Table[]
            - Concrete tables, Table[...]
      - Inhomogenouse & static containers / data structures
        - Concrete dictionaries (specifies the sufficient members)
        - Concrete tuples (specifies the sufficient members)
* How to add and check type annotation for:
  - any
  - never?
  - items of generic containers
  - input and output type of a function, for map
  - variants / sum-types
    - Similar to tuples/product-types.
    - Could add some syntax for sum-types like:
      Container = Variant(Stack String Table Number)
      container_of = in item out Variant([item] <item>)
  - optionals could either be sum-types or containers.
  - concepts:
    - concepts like Container, which is a sum-type of stack,string,table,number, boolean.
      - Could introduce a special type CONTAINER, similarly to EMPTY_STACK, and define equal accordingly.
    - Concepts like Functions, which is a sum type of function, function_tuple, function_dictionary, function_built_in.
      - Easy as long as we don't care about sub-concepts.
* Rename serialized types from NUMBER to Number.
* Dictionary types:
  - aoc_22_07
  - Should type checking for dictionaries be symmetric?
    Interfaces are typically not symmetric, i.e. the implementation has more details.
  - Should type checking for dictionaries not require exactly the same order?
* Run-time polymorphism/dispatch:
  - How to solve aoc_22_13
    if type checking would enforce homogeneous stacks?
  - Add version of "is" that checks that the type is equal
    instead of the value. "is_type_of" (bra)
  - Isinstance
  - Sum-type/choice-type
  - Run-time-dispatch/polymorphism/interfaces (bra)
    - Make type checking for dictionaries non-symmetric,
      so that a child can implement a parent interface and add more fields.
    - Add "using" 
  - dynamic keyword
* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}


STANDARD LIBRARY
* Make algorithms more similar to STL:
  - Let them take the "init container".
  - Add array containers/iterators that put new items in-place, similar to tables.
  - Then the same base algorithm can be used for both in-place (transform) and new allocation (map).
* all_of, any_of, none_of
* Interface for containers:
  - Look at all usages of clear in standard library, and consider sending in the target container/receiver, like STL.
  - Define and & or on tuples/pairs instead of stacks.
  - add empty? is_empty? function for containers?
    - Makes even more sense after for-loops are added.
    - nonempty, is_not_empty? is_populated, inhabited
    - empty = in container out is container
        [] then true
        "" then true
        <> then true
        0 then true
        else false
  - Compare interface for iterating over containers and numbers:
    - take!container, 1
    - drop!container, dec!number, --
    - put!(item container), add!(1 number), inc!number, +=
    - empty, 0
    - clear!container, [], "", <>, 0
    - put!(take!x drop!x) == x, add!(1 dec!x) == x
    - ett positivt heltal är ekvivalent med en stack, där bara längden på stacken spelar roll, men inte innehållet.
    - sub!(a b) == drop_n!(count!b a)
    - mul!(a b) == cartesian product?
    - div?
    - inc?
    - reverse!number == number
    - put_each!(a b) == add!(a b)
    - make_number!container == count!container
    - merge_stack!(a b) == sum_stack!(a b)
    - map_number!(f number) == sum_N f(n)
    - sum![numbers] == merge_stacks![stacks]
    - product![numbers] == cartesian product?
  - get vs indexing
    - Replace get!(key table default_value) for tables with container!key?
    - O(N) for stack and string
    - O(1) for table
  - count!containers
    - O(N) for stack and string
    - O(1) for table
  - Built-in functions for checking if name is in dict: has?(name dictionary) contains? inside?
    - O(N) for stack and string
    - O(1) for table
  - add higher_order function that takes a unary function and constructs a new binary function
    that applies identity to first argument, so that it can be used for table pairs of (key value).
  - add higher_order function that takes a unary predicate and constructs a new binary predicate
    that ignores the first argument, so that it can be used for table pairs of (key value).
  - Compare algorithms with those in libraries like: https://github.com/samber/lo
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
  - Let unordered be default since it makes sense for both stacks and tables.
  - clear_if_ordered, map_ordered.
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string


LANGUAGE SYNTAX & SEMANTICS
* Generic container interface. Make operations like inc,dec,drop,put,+=,--,get0,take consistent with serialization.
  - What do we refer to as first and last of a stack?
  - Should "take" give first or last?
  - Should we index from front or back?
  - Compare Peano axioms with generic programming and iterators.
    - Natural to have predecessor instead of successor for containers, since we can drop items without knowing what item we drop, but we cannot add an item without knowing what item we add.
    - Define generic programming axioms for containers using predecessor!
    - https://en.wikipedia.org/wiki/List_(abstract_data_type)
* Indexing
  - Allow both container!index and index!container. Second version is good for multiple indexing of images x!y!image.
  - Could also have index@container and x@y@image.
  - What about tables? When to return key-value-tuple and when to just return value?
    - get0,..., can already be used for tables. Mirror that behaviour.
    - table!index (make constant or logN?)
    - get!(key table default_value) (logN)
* Control structures for dictionaries.
  - Add syntactic sugar for numbers besides += like -=.
    - Use -= to subtract from number?
    - Use -= to remove a specific item from a table?
    - Use -= to drop N items from a container?
  - Add optionals and treat them like containers.
      x = optional[]
      x += 5
      flag = no
      for x
        flag = yes
      end
    put, clear, take, drop, +=, --
  - Syntax for homogeneous dynamic containers: stacks [], tables <(k v)>, optionals?
    - [], stack[]
    - <>, table[]
    - ?, optional[], option[] maybe[]
  - Empty tuple () for MISSING, NULL. Alternatively option[]
  - Add short-circuit "and" "or" to while statement.
* kebab-case
  - Numbers and -inf constant.
* Equality for dictionaries?
* Add asserts/value-checks/predicates with similar syntax to type-checks:
  - type-check:value-check;expression
  - List:is_populated;expression
  - List:expression
  - is_populated;expression
  - expression

SYSTEM IMPLEMENTATION
* Optimization:
  - Raytracer 32x20: 1.8,1.9,2.0,2.2,2.3s
* Nodes & Passes:
  - Parse
    - serialize
    - evaluate_types
      - serialize_types
    - evaluate
      - serialize
* Fewer heap allocations and more stack allocations.
  - Examples:
    - std::string in serialize.
    - std::vector for alternatives in Conditional and IsExpression.
    - std::vector in input_names for FunctionDictionary and FunctionTuple.
    - std::vector in Tuple and EvaluatedTuple.
    - std::vector in Dictionary and EvaluatedDictionary.
    - std::vector in Table.
    - std::map in EvaluatedTable and EvaluatedTableView.
  - Could implement on stack as fixed sized arrays like, possible many different like: Tuple4, Tuple8, Tuple16.
  - Could implement stacks and dictionaries as two indices/pointers to its first and last elements.
    - Maybe store all dictionary-statements in the same std::vector for faster dictionary iteration.
  - "Hash consing" for (booleans), characters and small numbers.
  - Adrian Sampson, Department of Computer Science Cornell University
    - Flattening ASTs (and Other Compiler Data Structures)- 
    - https://www.cs.cornell.edu/~asampson/blog/flattening.html
* Static evaluation names:
  - Current O(parents * members)
  - 1 in for number of steps to parent and another int for index in that dictionary. O(parents)
  - or just a single int for index in that dictionary, and then visit parents until it is found. O(parents)
* Storing all expression fields as SOA instead of AOS?
* James Gosling: "jvm bytecode as syntax tree in reverse polish notation".
  - Think of input and output of bytecode interpreter as flattened and efficient tree representation.
  - Compare iterators over an array.
* https://www.reddit.com/r/ProgrammingLanguages/comments/ugysu5/functional_language_for_data_descriptionconfig/
* Data & code in multiple files:
  - Importing source files.
  - Reading text file. Interpret text file as manglang source, but surround it with "" to make a string.

* Ranges. Store both stacks and tables as ranges.
  - Is it safe for stacks and tables, as long as we only do insertion but not erasure of the shared storage?
  - Or at least as long as we do not mutate while iterating.
  - https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers
* Persistent hash map like in Clojure. Array mapped hash tries (Bagwell: non-persistent, Rich Hickey: persistent).
  - HAMT - Hash Array Mapped Tries.
  - When making copies, it creates new nodes for the path from the root to the leaf, and shares the rest.
* Nils says that quasiquote and unquote and quote in racket could be a nice fit for manglang and vice versa, for macros and meta-programming.
  - Could add two operations and keywords: evaluate and anti-evaluate/devaluate/integrate/pass/ignore/skip/preserve
  - Let them have the semantics:
    evaluate preserve expression -> expression
  - "Evaluate" function as general solution that can be used to convert strings to names and general code, e.g. for parsing json.
* Advent of Code needs
  - Memory
    - 64 bit
    - Use less memory
* Memory management.
* Split structs for evaluated and non-evaluated for:
  - Dictionaries (done)
  - Lists (done)
  - Tables (done)
  - Functions (todo)
    - Sets environment and taret types for input.
* Error handling:
  - Add error messages as comments in source code.
    - Add (line) comments
    - // PARSE ERROR   ^ expected closing brace }
    - Remove old error message comments when there are no error messages.
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Article: "Concepts error messages for humans"
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* Rename to Mangelang?
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition

* Documentation and specification. Describe the steps and rules more formally, in metalanguage or graphical.
  - Parsing: manglang code -> tree. (EBNF, railroad diagrams)
  - Serializing: tree -> manglang code. (EBNF?, same as above?)
  - Evaluation: tree -> tree. (graphical nodes? algebra)


TOOLS:
* Command line interface for reading source from file and piping it to interpretor
* Web interpreter using wasm.
* Code formatting
  - Indentaiton and line breaks.
  - Colors and syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  - Homepage
  - Start by describing rules for wrapping different expressions.
    - Expressions with arbitrary number of sub-expressions:
      - Tuples, Dictionaries, Stacks, Tables, If, Is, FunctionTuple, FunctionDictionary.
        - 2 modes: single line or wrap with each item on its own line.
        - serialize(int indentation_level, int column_wrap_limit, ...)


EXAMPLE PROGRAMS:
* Raytracing
* Parsing Json
* Parsing Manglang
* Advent of code


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* Nix https://nixos.wiki/wiki/Overview_of_the_Nix_Language
* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/
* Sprylang http://sprylang.se/manual.html#composites

* (Cognate read) https://github.com/cognate-lang/cognate

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor


WEBPAGE
https://www.passerine.io/
https://gleam.run/
https://tabloid.vercel.app/
https://docs.scala-lang.org/tour/tour-of-scala.html
https://www.pyret.org/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://typst.app/docs/reference/text/strong/


Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARACTERS═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ DICTIONARIES ═════════╔═ STACKS══════════╔═ STRINGS ══════╗
║ {NAME=EXPRESSION ...}  ║ (EXPRESSION ...) ║ "CHARACTER..." ║
║                        ║                  ║                ║
║ {}                     ║ ()               ║ ""             ║
║                        ║                  ║                ║
║ {width=320 height=240} ║ (1 2 3)          ║ "abc"          ║
║                        ║                  ║                ║
║ {                      ║ (                ║ "Mang Lang"    ║
║     x = 1              ║     1            ║                ║
║     y = 2              ║     2            ║                ║
║     z = 3              ║     3            ║                ║
║ }                      ║ )                ║                ║
╚════════════════════════╚══════════════════╚════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ═════════════════╗
║ NAME               ║ NAME@EXPRESSION                    ║
║                    ║                                    ║
║ {                  ║ {                                  ║
║     x = 1          ║     rectangle = {width=1 height=2} ║
║     y = x          ║     w = width@rectangle            ║
║     z = {a=1 b=y}  ║     coordinate = z@{x=1 y=2 z=3}   ║
║ }                  ║ }                                  ║
╚════════════════════╚════════════════════════════════════╝

╔══ FUNCTION APPLICATION ════════════════════╗
║ NAME!EXPRESSION                            ║
║                                            ║
║ {                                          ║
║     list = (1 2 3)                         ║
║     num_elements = count!list              ║
║     longer_list = put!(0 list)             ║
║     backwards = reverse!"Mang Lang"        ║
║     area = get_area!{width=320 height=240} ║
║ }                                          ║
╚════════════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔═ ITERATIVE DICTIONARIES ═══════════════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} ║
║                                               ║                                                        ║
║ {                                             ║ {                                                      ║
║     is_rich = 0                               ║     sum = 0                                            ║
║     money = if is_rich then 1000000 else 1    ║     i = 10                                             ║
║     list = ()                                 ║     while i                                            ║
║     is_list_empty = if list then 1 else 0     ║         i = dec!i                                      ║
║ }                                             ║         sum = add!(sum i)                              ║
║                                               ║     end                                                ║
║                                               ║ }                                                      ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF STACKS ══════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME ...) out EXPRESSION    ║ in {NAME ...} out EXPRESSION               ║
║                                                   ║                                 ║                                            ║
║ {                                                 ║                                 ║                                            ║
║     square = in x out mul!(x x)                   ║                                 ║                                            ║
║     nine = square 3                               ║ {                               ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x y) out ║                                            ║
║         add!(square!vec!0, square!vec!1)          ║         add!(square!x square!y) ║                                            ║
║     n = square_norm2!(3 4)                        ║     n = square_norm2!(3 4)      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re im) out       ║     get_area = in {width height} out       ║
║         mul!(width@shape height@shape)            ║         (re neg!im)             ║         mul!(width height)                 ║
║     area = get_area!{width=320 height=240}        ║     c = conj!(0 1)              ║     area = get_area!{width=320 height=240} ║
║ }                                                 ║ }                               ║ }                                          ║
╚═══════════════════════════════════════════════════╚═════════════════════════════════╚════════════════════════════════════════════╝

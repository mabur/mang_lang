TODO:
* support numbers in variable names.
* Printing of row and column for syntax error.
* Printing of evaluation graph for run-time-errors.
* Start writing standard library functions in Mang Lang instead of Python.
* Try to implement Advent of Code problems to see what is missing
* Use-case: programmable json.
* railroad diagram / flow chart / ebnf definition

TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = värde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number, im:Number}
Complex : Type = {re:Number, im:Number}
x : Distance = 3
square : Number = mul[x, x]

// primitive to primitive:
square : from x:Number to Number = mul[x, x]

// record to primitive:
hyp : from {x:Number, y:Number} to Number = sqrt add[mul[x, x], mul[y, y]

// list to list:
conjugate : from x : List Number to List Number = [first x, neg last x]

// record to record:
conjugate : from {r:Number, i:Number} to {r:Number, i:Number} = {r := r, i := neg i}
conjugate : from Complex to Complex = {r := r, i := neg i}

// Type alias:
Complex : Type = {re:Number, im:Number}
complex := {re := 1, im := 1}
complex : Complex = {re : Number = 1, im : Number = 1}
re = re complex
im = im complex
conjugate : from {r:Number, i:Number} to {r:Number, i:Number} = {r := r, i := neg i}
conjugate : from Complex to Complex = {r := r, i := neg i}
complex2 = conjugate complex1

// Generics:
max_value : from List Generic to Generic = ...
max_index : from List Generic to Number = ...
max_split : from List Generic to List List Generic = ...

count_if : from {list: List Generic, predicate: from Generic to Boolean} to Number = ...
map: from {list: List Generic0, operation: from Generic0 to Generic1} to List Generic1 = ...
map2 : from {list0: List Generic0, list1: List Generic0, operation: from List Generic0 to Generic1} to List Generic1 = ...
map2heterogeneous : from {list0: List Generic0, list1: List Generic1, operation: from {value0: Generic0, value1: Generic1} to Generic2} to List Generic2 = ...

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real, y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)

-------------------------------------------------------------------------------------------------

split = from input to result of
{
  queue  = queue<input,
  query  = query<input,
  result = recursive_split {queue=queue, query=query, result=[]}
}

recursive_split = from input to
    if check_empty queue<input
    then input
    else output of
    {
      find_result = find {list=queue, query=","}, // Relies on find/split_first
      tail        = tail find_result,
      head        = head find_result,
      result      = concat [result, [head]]
      output      = recursive_split {queue=tail, result=result}
    }

move_element = from input to
    if equal [front source, query<input] then undefined else
    {
        target = concat [target<input, front source<input],
        source = without_front source<input,
        query = query<input
    }
move_word = move_element unfold {source=,target=[], query=","}
    


// Take a list and return a pair of lists: head and tail, or head, query, tail
find = ...
find_inclusive = ...
find_exclusive = ...

[1,2,3,4]

find(list=[1,2,3,4], query=3)
-> (head=[1,2], query=[3], tail=[4])

Parse "123,+56,345,-76,23"

parse_element = from input to find(list=input.string, query=',')

def split_for(input, query):
  output = []
  last_split_index = 0
  for index, element in enumerate(input):
      if element == query:
        word = input[last_split_index + 1:index]
        output.append(word)
        last_split_index = index
  word = input[last_split_index + 1:]
  if word:
    output.append(word)
  return output

def split_generator(first, last, query):
  if first != last:
    next = find_if(first, last, query)
    yield [first, next]
    yield from split_generator(++next, last, query)

// Denna verkar enkel. Skulle liknande funka i Manglang?
def split_recursive(first, last, query):
  if first == last:
    return []
  next = find_if(first, last, query)
  return [[first, next]] + split_generator(++next, last, query)


// Recursive split in Python:
def split_recursive(source, query):
  if not source:
    return []
  word, rest = next_word(source, query)
  return [word] + split_recursive(rest, query)

def next_word(source, query):
  if not source:
      return [], []
  if source[0] == query:
    return [], source[1:]
  word, rest = next_word(source[1:], query)
  return [source[0]] + word, rest

// Iterator split in C++:
std::vector<std::string> split(first, last, char query) {
  using namespace std;
  auto result = vector<string>{};
  auto next = find(first, last, query);
  do {
    if (first != next) {
      result.append(string{first, next});
    }
    first = ++next;
    next = find(first, last, query);
  } while (next != last)
  return result;
}

// Recursive split in C++:
std::vector<std::string> split_recursive(std::string source, char query)
{
    if (source.empty())
        return {};
    auto split = next_word(source, query);
    auto word = split[0];
    auto rest = split[1];
    auto recursive_result = split_recursive(rest, query);
    recursive_result.push_front(word);
    return recursive_result;
}

std::tuple<std::string, std::string> next_word(std::string source, char query) {
    using namespace std;
    if (source.empty)
        return make_tuple("", "");
    if (source[0] == query)
        return {{}, source.substr(1)};
    auto split = next_word(source.substr(1), query);
    auto word = get<0>(split);
    auto rest = get<1>(split);
    return make_tuple(source[0] + word, rest);
}

// Recursive split in Mang lang:
split_recursive = from input to
    if is_empty source<input then
        []
    else
        result<{
            query = query<input,
            source = source<input,
            split = next_word {source = source, query = query},
            word = word<split,
            rest = rest<split,
            recursive_result = split_recursive {source = rest, query = query},
            result = concat [word, recursive_result]
        }

next_word = from input to
    if is_empty source<input then
        {word = [], rest = []}
    else if equal [first source<input, query<input] then
        {word = [], rest = last_part source<input}
    else
        result<{
            source = source<input,
            query = query<input,
            tail = last_part source,
            split = next_word {source = tail, query = query},
            word = word<split,
            rest = rest<split,
            result = {word = concat [[first<source], word], rest = rest}
        }

// Multiple named input/output for functions:
split_recursive = from source, query to
    if is_empty source then
        []
    else
        result<{
            word, rest = next_word {source = source, query = query},
            recursive_result = split_recursive {source = rest, query = query},
            result = concat [word, recursive_result]
        }

next_word = from source, query to
    if is_empty source then
        {word = [], rest = []}
    else if equal [first source, query] then
        {word = [], rest = last_part source}
    else
        result<{
            word, rest = next_word {source = last_part source, query = query},
            result = {word = concat [[first source], word], rest = rest}
        }

// Blir bra. Implementera algoritmer från STL som find, find_if,
// men som returnerar listor istället för arrayer.
// find ger ger listorna [first, it] [it, end],
// där it kan vara end ifall den inte hittar något.
// next word ovan är typ find_if.

// F#
let find list query =
    match list width
        [] -> [[]; []]
        [query:] -> [[]; list]
        _ ->
            let [head: tail] = list
            let [center; new_tail] = find tail query
            let new_head = [head] + center
            [new_head, new_tail]

// Python
def find(list, query):
    if not list:
        return [[], []]
    if list[0] == query:
        return [[], list]
    center, tail = find(list=list[1:], query=query)
    head = [list[0]] + center
    return [head, tail]

// Nuvarande
find = from input to
    if is_empty list input then
        [[],[]]
    else if are_equal [first list input, query input] then
        [[], list input]
    else
        result {
            list = list input,
            query = query input,
            sub_result = find {list=last_part list, query=query}
            center = first sub_result,
            tail = last sub_result,
            head = concat [[first list], center],
            result = [head, tail]
        }


// Typ-förslag
find : from {list: List Generic, query: Generic} to List List Generic =
    if is_empty list then
        [[], []]
    else if are_equal [first list, query] then
        [[], list]
    else
        result {
            sub_result = find {list=last_part list, query=query},
            center = first sub_result,
            tail = last sub_result,
            head = concat [[first list], center],
            result = [head, tail]
        }

// Typ-förslag och pattern matching
find : from {list: List Generic, query: Generic} to List List Generic =
    if is_empty list then
        [[], []]
    else if are_equal [first list, query] then
        [[], list]
    else
        result {
            center, tail = find {list=last_part list, query=query},
            head = concat [[first list], center],
            result = [head, tail]
        }

TYPE SYSTEM
* How to add type annotation for:
  - dictionaries
  - tuples
  - functions
  - any
  - never?
  - variants / sum-types
    - Similar to tuples/product-types.
    - Could add some syntax for sum-types like:
      Container = |Stack String Table Number|
      container_of = in item out |[item] <item>|
  - optionals
    - Can we have type functions like:
    {
      make_optional = in Type out |Type NULL|
      OptionalNumber = make_optional!Number
      OptionalNumber = |Number NULL|
    }
  - items of generic containers
  - input and output type of a function, for map
  - concepts like Container, which is a sum-type of stack,string,table,number.
    - Could introduce a special type CONTAINER, similarly to EMPTY_STACK, and define equal accordingly.
  - concepts like BooleanLike, which is a sum-type of Container and Boolean.
    - Could introduce a special type BOOLEAN_TYPE, similarly to EMPTY_STACK, and define equal accordingly.
    - Could also remove this concept ant not define truthy/falsey for containers.
    - Could also define the functions to take only Booleans, and not use them for Containers of Containers.
  - Concepts like Functions
* Run-time polymorphism/dispatch:
  - How to solve aoc_22_13
    if type checking would enforce homogeneous stacks?
  - Add version of "is" that checks that the type is equal
    instead of the value. "is_type_of" (bra)
  - Isinstance
  - Inheritance/polymorphism
  - Run-time-dispatch
  - Sum-type/choice-type
  - dynamic keyword
* Rename serialized types from NUMBER to Number.

STANDARD LIBRARY
* all_of, any_of, none_of
* Interface for containers:
  - Define and & or on tuples/pairs instead of stacks.
  - add empty? is_empty? function for containers?
    - Makes even more sense after for-loops are added.
    - nonempty, is_not_empty? populated, inhabited
    - empty = in container out is container
        [] then true
        "" then true
        <> then true
        0 then true
        else false
  - Compare interface for iterating over containers and numbers:
    - take!container, 1
    - drop!container, dec!number, --
    - put!(item container), add!(1 number), inc!number, +=
    - empty, 0
    - clear!container, [], "", <>, 0
    - put!(take!x drop!x) == x, add!(1 dec!x) == x
    - ett positivt heltal är ekvivalent med en stack, där bara längden på stacken spelar roll, men inte innehållet.
    - sub!(a b) == drop_n!(count!b a)
    - mul!(a b) == cartesian product?
    - div?
    - inc?
    - reverse!number == number
    - put_each!(a b) == add!(a b)
    - make_number!container == count!container
    - merge_stack!(a b) == sum_stack!(a b)
    - map_number!(f number) == sum_N f(n)
    - sum![numbers] == merge_stacks![stacks]
    - product![numbers] == cartesian product?
  - get vs indexing
    - Replace get!(key table default_value) for tables with container!key?
    - O(N) for stack and string
    - O(1) for table
  - count!containers
    - O(N) for stack and string
    - O(1) for table
  - Built-in functions for checking if name is in dict: has?(name dictionary) contains? inside?
    - O(N) for stack and string
    - O(1) for table
  - add higher_order function that takes a unary function and constructs a new binary function
    that applies identity to first argument, so that it can be used for table pairs of (key value).
  - add higher_order function that takes a unary predicate and constructs a new binary predicate
    that ignores the first argument, so that it can be used for table pairs of (key value).
  - Compare algorithms with those in libraries like: https://github.com/samber/lo
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
  - Let unordered be default since it makes sense for both stacks and tables.
  - clear_if_ordered, map_ordered.
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string


LANGUAGE SYNTAX & SEMANTICS
* Generic container interface. Make operations like inc,dec,drop,put,+=,--,get0,take consistent with serialization.
  - What do we refer to as first and last of a stack?
  - Should "take" give first or last?
  - Should we index from front or back?
  - Compare Peono axioms with generic programming and iterators.
    - Natural to have predecessor instead of successor for containers, since we can drop items without knowing what item we drop, but we cannot add an item without knowing what item we add.
    - Define generic programming axioms for containers using predecessor!
* Indexing
  - Allow both container!index and index!container. Second version is good for multiple indexing of images x!y!image.
  - What about tables? When to return key-value-tuple and when to just return value?
    - get0,..., can already be used for tables. Mirror that behaviour.
    - table!index (make constant or logN?)
    - get!(key table default_value) (logN)
* Control structures for dictionaries.
  - Implement more control structures like if by first refactoring dictionary statements,
    so that we can have hierarchical groups of statements corresponding to "scope".
  - Support index in for loop:
    for index, item in container
    container2 = enumerate!container for pair in container2
  - Add syntactic sugar for numbers besides += like -=.
    - Use -= to subtract from number?
    - Use -= to remove a specific item from a table?
    - Use -= to drop N items from a container?
  - Conditional return statements for dictionary
      return if a
  - If statements for dictionaries.
      if a
        b = c
      end
  - Add short-circuit "and" "or" to while statement.
* Empty tuple () for MISSING, NULL.
* kebab-case
  - Numbers and -inf constant.
* Equality for dictionaries?
* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}


SYSTEM IMPLEMENTATION
* Nodes & Passes:
  - Parse
    - serialize
    - evaluate_types
      - serialize_types
    - evaluate
      - serialize
* Better error messages:
  - Always run type checking for better error messages.
* James Gosling: "jvm bytecode as syntax tree in reverse polish notation".
  - Think of input and output of bytecode interpreter as flattened and efficient tree representation.
  - Compare iterators over an array.
* https://www.reddit.com/r/ProgrammingLanguages/comments/ugysu5/functional_language_for_data_descriptionconfig/
* Data & code in multiple files:
  - Importing source files.
  - Reading text file. Interpret text file as manglang source, but surround it with "" to make a string.

* Ranges. Store both stacks and tables as ranges.
  - Is it safe for stacks and tables, as long as we only do insertion but not erasure of the shared storage?
  - Or at least as long as we do not mutate while iterating.
  - https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers
* Persistent hash map like in Clojure. Array mapped hash tries (Bagwell: non-persistent, Rich Hickey: persistent).
  - HAMT - Hash Array Mapped Tries.
  - When making copies, it creates new nodes for the path from the root to the leaf, and shares the rest.
* Nils says that quasiquote and unquote and quote in racket could be a nice fit for manglang and vice versa, for macros and meta-programming.
  - Could add two operations and keywords: evaluate and anti-evaluate/devaluate/integrate/pass/ignore/skip/preserve
  - Let them have the semantics:
    evaluate preserve expression -> expression
  - "Evaluate" function as general solution that can be used to convert strings to names and general code, e.g. for parsing json.
* Advent of code Needs
  * Look at advent of code 2021 day 10 for example of code with a bit of friction
    - Try to implement calculation of most common words in a text.
  * Memory
    - 64 bit
    - Use less memory
* Memory management.
* Split structs for evaluated and non-evaluated for:
  - Dictionaries (done)
  - Lists (done)
  - Tables (done)
  - Functions (todo)
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* Rename to Mangelang?
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition

* Documentation and specification. Describe the steps and rules more formally, in metalanguage or graphical.
  - Parsing: manglang code -> tree. (EBNF, railroad diagrams)
  - Serializing: tree -> manglang code. (EBNF?, same as above?)
  - Evaluation: tree -> tree. (graphical nodes? algebra)


TOOLS:
* Type checking from command line.
* Command line interface for reading source from file and piping it to interpretor
* Code formatting
  - Indentaiton and line breaks.
  - Colors and syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  - Homepage
* Web interpreter using wasm.


EXAMPLE PROGRAMS:
* Raytracing
* Parsing Json
* Parsing Manglang
* Advent of code


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* Nix https://nixos.wiki/wiki/Overview_of_the_Nix_Language
* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/
* Sprylang http://sprylang.se/manual.html#composites

* (Cognate read) https://github.com/cognate-lang/cognate

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor


WEBPAGE
https://www.passerine.io/
https://gleam.run/
https://tabloid.vercel.app/
https://docs.scala-lang.org/tour/tour-of-scala.html
https://www.pyret.org/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang


Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARACTERS═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ DICTIONARIES ═════════╔═ STACKS══════════╔═ STRINGS ══════╗
║ {NAME=EXPRESSION ...}  ║ (EXPRESSION ...) ║ "CHARACTER..." ║
║                        ║                  ║                ║
║ {}                     ║ ()               ║ ""             ║
║                        ║                  ║                ║
║ {width=320 height=240} ║ (1 2 3)          ║ "abc"          ║
║                        ║                  ║                ║
║ {                      ║ (                ║ "Mang Lang"    ║
║     x = 1              ║     1            ║                ║
║     y = 2              ║     2            ║                ║
║     z = 3              ║     3            ║                ║
║ }                      ║ )                ║                ║
╚════════════════════════╚══════════════════╚════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ═════════════════╗
║ NAME               ║ NAME@EXPRESSION                    ║
║                    ║                                    ║
║ {                  ║ {                                  ║
║     x = 1          ║     rectangle = {width=1 height=2} ║
║     y = x          ║     w = width@rectangle            ║
║     z = {a=1 b=y}  ║     coordinate = z@{x=1 y=2 z=3}   ║
║ }                  ║ }                                  ║
╚════════════════════╚════════════════════════════════════╝

╔══ FUNCTION APPLICATION ════════════════════╗
║ NAME!EXPRESSION                            ║
║                                            ║
║ {                                          ║
║     list = (1 2 3)                         ║
║     num_elements = count!list              ║
║     longer_list = put!(0 list)             ║
║     backwards = reverse!"Mang Lang"        ║
║     area = get_area!{width=320 height=240} ║
║ }                                          ║
╚════════════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔═ ITERATIVE DICTIONARIES ═══════════════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} ║
║                                               ║                                                        ║
║ {                                             ║ {                                                      ║
║     is_rich = 0                               ║     sum = 0                                            ║
║     money = if is_rich then 1000000 else 1    ║     i = 10                                             ║
║     list = ()                                 ║     while i                                            ║
║     is_list_empty = if list then 1 else 0     ║         i = dec!i                                      ║
║ }                                             ║         sum = add!(sum i)                              ║
║                                               ║     end                                                ║
║                                               ║ }                                                      ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF STACKS ══════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME ...) out EXPRESSION    ║ in {NAME ...} out EXPRESSION               ║
║                                                   ║                                 ║                                            ║
║ {                                                 ║                                 ║                                            ║
║     square = in x out mul!(x x)                   ║                                 ║                                            ║
║     nine = square 3                               ║ {                               ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x y) out ║                                            ║
║         add!(square!vec!0, square!vec!1)          ║         add!(square!x square!y) ║                                            ║
║     n = square_norm2!(3 4)                        ║     n = square_norm2!(3 4)      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re im) out       ║     get_area = in {width height} out       ║
║         mul!(width@shape height@shape)            ║         (re neg!im)             ║         mul!(width height)                 ║
║     area = get_area!{width=320 height=240}        ║     c = conj!(0 1)              ║     area = get_area!{width=320 height=240} ║
║ }                                                 ║ }                               ║ }                                          ║
╚═══════════════════════════════════════════════════╚═════════════════════════════════╚════════════════════════════════════════════╝

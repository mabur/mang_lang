TODO:
https://www.reddit.com/r/ProgrammingLanguages/comments/ugysu5/functional_language_for_data_descriptionconfig/
* Document table functions.
* Type checking for tables.
  - Enforce homogenous keys and values for type checking. Unlike dictionaries that have homogeneous keys/labels but heterogenous values.
* Change syntax for tables from <a:b c:d> to <(a b) (c d)>.
* Interface for containers and tables:
  - Merge get_index!(n container) for containers and get!(key table default_value) for tables?
  - put!(item stack)
  - set!((key value) table)
  - add generic map that requires that f has same input and output type,
    so that it does not change type of the container.
    Then the same map could be used for stack, string, table.
    That map could be used instead of replace_*.
  - Rename find_* to remove/drop until something is found, to work better with tables. 
  - add higher_order function that takes a unary function and constructs a new binary function
    that applies identity to first argument, so that it can be used for table pairs of (key value).
  - add higher_order function that takes a unary predicate and constructs a new binary predicate
    that ignores the first argument, so that it can be used for table pairs of (key value).
(
* top!container
  - value for stack and string
  - (key value) for table
* rest!containers
  - immutable for stack and strings
  - mutable for table
  - imutable view for table
)

* clear!container
  - new empty container of same type
* put/set!(item container)
  - item = value for stack and strings
  - item = (key value) for table
* fold!(operation stack init)
  - (Alternative 1 operate on value)
  - Alternative 2 operate on (key value)

* get/get_index!(key table default_value)
  - O(N) for stack and string
  - O(1) for table
* count!containers
  - O(N) for stack and string
  - O(1) for table

* Functions that can have shared implementation (folds):
  - reverse/copy
  - put_each
  - map_same
  - clear_if / filter

  - count_if
  - sum
  - product
  - min
  - max

* Unresolved folds with early exit:
  - find_if
  - find_item
  - contains
  - Could resolve by implementing as normal fold and avoiding early exit:
    - any
    - all
    - none
  - Could resolve by having one of them as built-in.
  - Could resolve by having find_if as built-in.
    find_if = in (predicate container) out container@{
        container = container
        while if container then not!predicate?top@container else no
            container = rest@container
        end
    }


* Stack and table comprehension and fold/reduction?
* Iterators:
  - top / *
    - first element for stack
    - first element for table
    - current element for table/view/range
  - rest / next
    - imutable rest for stack
    - imutable view for table
    - imutable view for view
  - boolean?rest / != end
* Add ImmutableTableView
* Ranges. Store both stacks and tables as ranges.
  - Is it safe for stacks and tables, as long as we only do insertion but not erasure of the shared storage?
  - Or at least as long as we do not mutate while iterating.
  - https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers
  - Investigate crashes in current implementation, probably due to bad iterators for TableView and mutations.
    - Maybe due to making temporary copies of the Table and then taking iterators for the copy?

* Identity
  - put!(top@stack rest@stack) == stack
  - Alternative 1 - Do not keep it for tables. Simplifies generalization of:
    - sum, prod, all, any, none.
    - Easy to circumvent by e.g. sum!get_values!table
  - Alternative 2 - Better? - Keep it for tables. Simplifies generalization of:
    - put_each, concat, map*, clear_if
    - Optionally: Implement by having items of table be stored as Manglang tuples?
      - Pros:
        - Then we don't need to create tuples on the fly when calling top@table.
      - Cons:
        - Then we need to creat new tuples when mutating the table.
      - Maybe not important for now.
    - Replace set with put for tables.
      - Does it relate to crashes below?
    
* Persistent hash map like in Clojure. Array mapped hash tries (Bagwell: non-persistent, Rich Hickey: persistent).
  - HAMT - Hash Array Mapped Tries.
  - When making copies, it creates new nodes for the path from the root to the leaf, and shares the rest.

* Nils says that quasiquote and unquote and quote in racket could be a nice fit for manglang and vice versa, for macros and meta-programming.
  - Could add two operations and keywords: evaluate and anti-evaluate/devaluate/integrate/pass/ignore/skip/preserve
  - Let them have the semantics:
    evaluate preserve expression -> expression
  - "Evaluate" function as general solution that can be used to convert strings to names and general code, e.g. for parsing json.
* Tools:
  - Type checking.
  - Command line interface for reading source from file and piping it to interpretor
* Code formatting
  - Indentaiton and line breaks.
  - Colors and syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  - Homepage
* Advent of code Needs
  * Look at advent of code 2021 day 10 for example of code with a bit of friction
    - Try to implement calculation of most common words in a text.
  * Memory
    - 64 bit
    - Use less memory
* Example programs:
  - Parsing Json
  - Parsing Manglang
  - Raytracing
* Memory management.
* Built-in functions for checking if name is in dict: has?(name dictionary) contains? inside?
* Empty tuple () for MISSING, NULL.
* kebab-case
  - Numbers and -inf constant.
* Equality for dictionaries?
* Split structs for evaluated and non-evaluated for:
  - Dictionaries (done)
  - Lists (done)
  - Tables (done)
  - Functions (todo)
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* Is manglang suitable for numerical computations on arrays?
* vector math
  - Define add, sub, mul, div so that they only take two inputs that could be either list of numbers or number.
  - norms, dot, inner_products
* Generic programming
  - Generic container interface.
  - Describe ListBase as a "Concept".
* Rename to Mangelang?
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition
* Importing source files.
* Documentation and specification. Describe the steps and rules more formally, in metalanguage or graphical.
  - Parsing: manglang code -> tree. (EBNF, railroad diagrams)
  - Serializing: tree -> manglang code. (EBNF?, same as above?)
  - Evaluation: tree -> tree. (graphical nodes? algebra)

* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}

* Problem with lookup of first and rest inside list environment 
{
  first = ...
  rest = ...
  result = f(first rest)
}


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/

* (Cognate read) https://github.com/cognate-lang/cognate

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/
https://docs.scala-lang.org/tour/tour-of-scala.html

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARACTERS═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ DICTIONARIES ═════════╔═ STACKS══════════╔═ STRINGS ══════╗
║ {NAME=EXPRESSION ...}  ║ (EXPRESSION ...) ║ "CHARACTER..." ║
║                        ║                  ║                ║
║ {}                     ║ ()               ║ ""             ║
║                        ║                  ║                ║
║ {width=320 height=240} ║ (1 2 3)          ║ "abc"          ║
║                        ║                  ║                ║
║ {                      ║ (                ║ "Mang Lang"    ║
║     x = 1              ║     1            ║                ║
║     y = 2              ║     2            ║                ║
║     z = 3              ║     3            ║                ║
║ }                      ║ )                ║                ║
╚════════════════════════╚══════════════════╚════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ═════════════════╗
║ NAME               ║ NAME@EXPRESSION                    ║
║                    ║                                    ║
║ {                  ║ {                                  ║
║     x = 1          ║     rectangle = {width=1 height=2} ║
║     y = x          ║     w = width@rectangle            ║
║     z = {a=1 b=y}  ║     coordinate = z@{x=1 y=2 z=3}   ║
║ }                  ║ }                                  ║
╚════════════════════╚════════════════════════════════════╝

╔══ FUNCTION APPLICATION ════════════════════╗
║ NAME!EXPRESSION                            ║
║                                            ║
║ {                                          ║
║     list = (1 2 3)                         ║
║     num_elements = count!list              ║
║     longer_list = put!(0 list)             ║
║     backwards = reverse!"Mang Lang"        ║
║     area = get_area!{width=320 height=240} ║
║ }                                          ║
╚════════════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔═ ITERATIVE DICTIONARIES ═══════════════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} ║
║                                               ║                                                        ║
║ {                                             ║ {                                                      ║
║     is_rich = 0                               ║     sum = 0                                            ║
║     money = if is_rich then 1000000 else 1    ║     i = 10                                             ║
║     list = ()                                 ║     while i                                            ║
║     is_list_empty = if list then 1 else 0     ║         i = dec!i                                      ║
║ }                                             ║         sum = add!(sum i)                              ║
║                                               ║     end                                                ║
║                                               ║ }                                                      ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF STACKS ══════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME ...) out EXPRESSION    ║ in {NAME ...} out EXPRESSION               ║
║                                                   ║                                 ║                                            ║
║ {                                                 ║                                 ║                                            ║
║     square = in x out mul!(x x)                   ║                                 ║                                            ║
║     nine = square 3                               ║ {                               ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x y) out ║                                            ║
║         add!(square!first!vec, square!second!vec) ║         add!(square!x square!y) ║                                            ║
║     n = square_norm2!(3 4)                        ║     n = square_norm2!(3 4)      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re im) out       ║     get_area = in {width height} out       ║
║         mul!(width@shape height@shape)            ║         (re neg!im)             ║         mul!(width height)                 ║
║     area = get_area!{width=320 height=240}        ║     c = conj!(0 1)              ║     area = get_area!{width=320 height=240} ║
║ }                                                 ║ }                               ║ }                                          ║
╚═══════════════════════════════════════════════════╚═════════════════════════════════╚════════════════════════════════════════════╝

TODO:
* Functions:
  - Math: ceil/round_up, floor/round_down, round
  - Character: to_upper, to_lower, is_alpha, is_digit, to_number, to_ascii
  - child@ as function that can be sent to map
  - Implement equal for dictionary
  - rename functions first and rest to first! and rest! to not confuse noun/result from verb/function
  - Naming of count_*, range, reverse_range, enumerate.
* Error handling:
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
* Command line interface for reading source from file and piping it to interpretor
* Homepage
  - Make logo: double lambda: https://docs.google.com/document/d/1QNm45cydqxuvMwjXDq3DtXoxuaiTAexnQ8VEtgLwjpM/edit
  - Improve home-page.
  - Prettier homepage.
  - Syntax high-lighting.
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Imperative Support
  - Redefinition of symbols in dictionaries
  - while in dictionaries
  - only support mutation of symbols in current dictionary
  - avoid global mutable state
  - hides mutation, so that each unit is pure from the outside
  - do not allow other side-effects
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries. 
* Not turing complete
  - Remove recursion and replace with map/filter/fold/list-comprehension/sql
* higher order function for for-loop, that can be used instead of recursion for long lists
 - iterate{start=1, while=p, update=f}
 - operator:
    iterate "start" while "while" update "update"
    iterate "start" by "update" while "while"
    iterate "start" to "update" while "while"
    iterate "start" with "update" while "while"
    for "start" while "while" update "update"
 - function comprehension:
    in ... out ... while ...
    iterate ... out ... while ...
    repeat ... out ... while ...
    iterate ... while ...
 - fold
 - How to specify starting point for generic functions () and "", when not using recursion?
   - Return input if empty otherwise start with first element instead of empty element? Would that work?
   - have empty function?
* Parser combinators
* Tail call optimization.
* Mutable dictionary definition

count = in list out (if list then (inc (count (rest (list)))) else 0)

given x return mul[x, x]
in x out mul[x, x]
in x out mul[x, x]
>> x >> mul[x, x]
-> x -> mul[x, x]
> x > mul[x, x]

LEVELS
1. Data
   - numbers
   - characters
   - strings
   - lists
   - dictionaries
2. References
   - reference (substitution)
   - child reference (substitution)
3. Computation
   - if (substitution)
   - function definition
   - function call (substitution)
4. Imperative
   - while in dictionaries and updating of symbols (substitution)

SIMILAR LANGUAGES
* Lisp family
* Json
* Yaml
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* L1 https://mlajtos.github.io/L1/
* Azor: https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL

replace x with mul[x, x]
in x out mul[x, x]
out mul[x, x] in x
in [a, b] out mul[a, b]
in {a, b} out mul[a, b]
x: -> mul[x, x]
[a:, b:] -> mul[a, b]
{a:, b:} -> mul[a, b]
x> mul[x, x]
[a> b>] mul[a, b]
{a> b>} mul[a, b]

Equivalence of:
in input out list@input
list@input in input
input>list@input
list@

in country out street@city@country
country>street@city@country
street@city@
street@city@country in country

iterate = in {start, update, while} out 
    if while start then
        iterate {start = update start, update = update, while = while}
    else
        init
// Higher order function:
factorial = in x out product@{
    update = in {product, x} out {product = mul [product, x], i = dec x},
    while = in {x} out not equal [x, 1],
    product = produxct@iterate{start = {product = 1, x = x}, update = update, while = while} 
}
// Operator:
factorial = in x out product@
    iterate {product = 1, x = x}
    out {product = mul [product, x], x = dec x}
    while not equal [x, 1]
// Function comprehension:
factorial = in x out product@{
    f = in {product, x} out {product = mul [product, x], x = dec x} while not equal [x, 1]
    product = f {product=1, x=x}
}
// Function comprehension alternative:
factorial = in x out product@{
    f = iterate {product = mul [product, x], x = dec x} while not equal [x, 1]
    product = f {product=1, x=x}
}
// Recursion:
count = in list out
    if list then
        inc count rest list
    else
        0,
// Operator:
count = in list out count@
    iterate {count=0, list=list}
    out {count = inc count, list = rest list}
    while list
// Mutable dictionaries:
count = in list out result@{
  result = 0,
  tail = list,
  while tail,
    result = inc result,
    tail = rest tail,
  end
}
// Operator:
reverse = in list out new_list@
    iterate {new_list = empty(list), tail = list}
    out {new_list = prepend(first tail, new_list), tail = rest tail}
    while tail
// Mutable dictionaries:
reverse = in list out new_list@{
    new_list = empty(list),
    tail = list,
    while tail,
      new_list = prepend(first tail, new_list),
      tail = rest tail,
    end
}


* Implement lists as dictionaries {first, rest} or {}?
  - functions first and rest can be replaced with member lookup first@ and rest@
  - prepend can be replaced with dict construction {first=first, rest=rest}
  - Can reverse be implemented in standard-library? yes, but I don't know if it can be made generic
  - How to differentiate between strings and lists?

    [] -> {type=list}
    [1] -> {first=1,rest={},type=list}
    [1,2] -> {first=1,rest={first=2,rest={},type=list},type=list}

    "" -> {type=character}
    "a" -> {first='a',rest={},type=list}
    "ab" -> {first='a',rest={first='b',rest={},type=list},type=list}

    {first=1,rest=[1,2], type=list}
    prepend{first=1,rest=[1,2]}
    list{first=1,rest=[1,2]}
    string{first='a',rest="bc"}


    How to serialize?
    - Have type field {type=character}
    - Have hidden type information
    How to store efficiently? No problem.
    - Use hash-function to go from string to number, so that we internally can store keys as numbers instead of strings.


TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = värde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number, im:Number}
Complex : Type = {re:Number, im:Number}
x : Distance = 3
square : Number = mul[x, x]

// primitive to primitive:
square : in x:Number out Number = mul[x, x]
square : x : Number -> Number = mul[x, x]
square : x : -> = mul[x, x]
square: = x: -> mul[x, x]
square = in x out mul[x, x]

// record to primitive:
hyp : in {x:Number, y:Number} out Number = sqrt add[mul[x, x], mul[y, y]

// list to list:
conjugate : in x : List Number out List Number = [first x, neg last x]

// record to record:
conjugate : in {r:Number, i:Number} out {r:Number, i:Number} = {r := r, i := neg i}
conjugate : in Complex out Complex = {r := r, i := neg i}

// Type alias:
Complex : Type = {re:Number, im:Number}
complex := {re := 1, im := 1}
complex : Complex = {re : Number = 1, im : Number = 1}
re = re complex
im = im complex
conjugate : in {r:Number, i:Number} out {r:Number, i:Number} = {r := r, i := neg i}
conjugate : in Complex out Complex = {r := r, i := neg i}
complex2 = conjugate complex1

// Generics:
max_value : in List Generic out Generic = ...
max_index : in List Generic out Number = ...
max_split : in List Generic out List List Generic = ...

count_if : in {list: List Generic, predicate: in Generic out Boolean} out Number = ...
map: in {list: List Generic0, operation: in Generic0 out Generic1} out List Generic1 = ...
map2 : in {list0: List Generic0, list1: List Generic0, operation: in List Generic0 out Generic1} out List Generic1 = ...
map2heterogeneous : in {list0: List Generic0, list1: List Generic1, operation: in {value0: Generic0, value1: Generic1} out Generic2} out List Generic2 = ...

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real, y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)

-------------------------------------------------------------------------------------------------

split = in input out result of
{
  queue  = queue@input,
  query  = query@input,
  result = recursive_split {queue=queue, query=query, result=[]}
}

recursive_split = in input out
    if check_empty queue@input
    then input
    else output@
    {
      find_result = find {list=queue, query=","}, // Relies on find/split_first
      tail        = tail find_result,
      head        = head find_result,
      result      = concat [result, [head]]
      output      = recursive_split {queue=tail, result=result}
    }

move_element = in input out
    if equal [front source, query@input] then undefined else
    {
        target = concat [target@input, front source@input],
        source = without_front source@input,
        query = query@input
    }
move_word = move_element unfold {source=,target=[], query=","}
    


// Take a list and return a pair of lists: head and tail, or head, query, tail
find = ...
find_inclusive = ...
find_exclusive = ...

[1,2,3,4]

find(list=[1,2,3,4], query=3)
-> (head=[1,2], query=[3], tail=[4])

Parse "123,+56,345,-76,23"

parse_element = in input out find(list=input.string, query=',')

def split_for(input, query):
  output = []
  last_split_index = 0
  for index, element in enumerate(input):
      if element == query:
        word = input[last_split_index + 1:index]
        output.append(word)
        last_split_index = index
  word = input[last_split_index + 1:]
  if word:
    output.append(word)
  return output

def split_generator(first, last, query):
  if first != last:
    next = find_if(first, last, query)
    yield [first, next]
    yield in split_generator(++next, last, query)

// Denna verkar enkel. Skulle liknande funka i Manglang?
def split_recursive(first, last, query):
  if first == last:
    return []
  next = find_if(first, last, query)
  return [[first, next]] + split_generator(++next, last, query)


// Recursive split in Python:
def split_recursive(source, query):
  if not source:
    return []
  word, rest = next_word(source, query)
  return [word] + split_recursive(rest, query)

def next_word(source, query):
  if not source:
      return [], []
  if source[0] == query:
    return [], source[1:]
  word, rest = next_word(source[1:], query)
  return [source[0]] + word, rest

// Iterator split in C++:
std::vector<std::string> split(first, last, char query) {
  using namespace std;
  auto result = vector<string>{};
  auto next = find(first, last, query);
  do {
    if (first != next) {
      result.append(string{first, next});
    }
    first = ++next;
    next = find(first, last, query);
  } while (next != last)
  return result;
}

// Recursive split in C++:
std::vector<std::string> split_recursive(std::string source, char query)
{
    if (source.empty())
        return {};
    auto split = next_word(source, query);
    auto word = split[0];
    auto rest = split[1];
    auto recursive_result = split_recursive(rest, query);
    recursive_result.push_front(word);
    return recursive_result;
}

std::tuple<std::string, std::string> next_word(std::string source, char query) {
    using namespace std;
    if (source.empty)
        return make_tuple("", "");
    if (source[0] == query)
        return {{}, source.substr(1)};
    auto split = next_word(source.substr(1), query);
    auto word = get<0>(split);
    auto rest = get<1>(split);
    return make_tuple(source[0] + word, rest);
}

// Recursive split in Mang lang:
split_recursive = in input out
    if is_empty source@input then
        []
    else
        result@{
            query = query@input,
            source = source@input,
            split = next_word {source = source, query = query},
            word = word@split,
            rest = rest@split,
            recursive_result = split_recursive {source = rest, query = query},
            result = concat [word, recursive_result]
        }

next_word = in input out
    if is_empty source@input then
        {word = [], rest = []}
    else if equal [first source@input, query@input] then
        {word = [], rest = last_part source@input}
    else
        result@{
            source = source@input,
            query = query@input,
            tail = last_part source,
            split = next_word {source = tail, query = query},
            word = word@split,
            rest = rest@split,
            result = {word = concat [[first@source], word], rest = rest}
        }

// Multiple named input/output for functions:
split_recursive = in source, query out
    if is_empty source then
        []
    else
        result@{
            word, rest = next_word {source = source, query = query},
            recursive_result = split_recursive {source = rest, query = query},
            result = concat [word, recursive_result]
        }

next_word = in source, query out
    if is_empty source then
        {word = [], rest = []}
    else if equal [first source, query] then
        {word = [], rest = last_part source}
    else
        result@{
            word, rest = next_word {source = last_part source, query = query},
            result = {word = concat [[first source], word], rest = rest}
        }

// Blir bra. Implementera algoritmer från STL som find, find_if,
// men som returnerar listor istället för arrayer.
// find ger ger listorna [first, it] [it, end],
// där it kan vara end ifall den inte hittar något.
// next word ovan är typ find_if.

// F#
let find list query =
    match list width
        [] -> [[]; []]
        [query:] -> [[]; list]
        _ ->
            let [head: tail] = list
            let [center; new_tail] = find tail query
            let new_head = [head] + center
            [new_head, new_tail]

// Python
def find(list, query):
    if not list:
        return [[], []]
    if list[0] == query:
        return [[], list]
    center, tail = find(list=list[1:], query=query)
    head = [list[0]] + center
    return [head, tail]

// Nuvarande
find = in {list, query} out
    if is_empty list then
        [[],[]]
    else if are_equal [first list, query] then
        [[], list]
    else
        result@{
            sub_result = find {list=rest list, query=query}
            center = first sub_result,
            tail = first rest sub_result,
            head = concat [[first list], center],
            result = [head, tail]
        }
// Typ-förslag
find : in {list: List Generic, query: Generic} out List List Generic =
    if is_empty list then
        [[], []]
    else if are_equal [first list, query] then
        [[], list]
    else
        result {
            sub_result = find {list=rest list, query=query},
            center = first sub_result,
            tail = first rest sub_result,
            head = concat [[first list], center],
            result = [head, tail]
        }

// Typ-förslag och pattern matching
find : in {list: List Generic, query: Generic} out List List Generic =
    if is_empty list then
        [[], []]
    else if are_equal [first list, query] then
        [[], list]
    else
        result {
            center, tail = find {list=rest list, query=query},
            head = concat [[first list], center],
            result = [head, tail]
        }

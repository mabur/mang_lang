TODO:
* Advent of code Needs
  * Look at advent of code 2021 day 10 for example of code with a bit of friction
    - Try new is-operator
  * Dynamic dictionary keys, as a way to model sets and arrays, 
    - Store content of IterativeDictionary as array, for simple control flow while.
    - Store content of evaluated Dictionary as hash-map, for fast lookup for big dicts and arrays.
    - Dictionaries with other keys than strings and dynamic lookup.
    - Built-in function for dynamic lookup of dictionaries: get!(key dictionary) get!(index dictionary)
    - Dictionaries as arrays with integer keys and dynamic lookups

    get_closer = in c out get!(c {
            ['('] = ')'
            ['{'] = '}'
            ['['] = ']'
            ['<'] = '>'
        })
  {
      N = 10
      result = {    
          i = 1
          while less?(i N)
              j = dec!i
              [i] = [j]
              i = inc!i
              key = (1 2)
              [key] = 1
              [(1 2)] = 1
          end
      }
      i = i@result
      j = j@result
      c = get!(2 result)
      d = get!(i result)
      e = get!(dec!N result)
      f = get!((1 2) result)
  }

  * Arrays as special mutable type, with shared mutable state among references.
    - put. Let it be defined for arrays that have capacity and where the current reference is refering to the whole array and not a sub range. Otherwise run-time error.
  * aoc algorithms in need:
    - sort
    - unique
    - not unique
    - Dynamic lookups of dictionary
    - Dynamic dictionaries/hash-maps/sets for unique-check
    - General dictionary keys using serializing to string under the hood.
  * Memory
    - 64 bit
    - Use less memory
* Simplifications with new list:
  - Merge new list and new string?
  - Extract for_each for new lists and strings
  - resolve mutable pointer in iterative dictionary evaluation
  - remove shared_ptr from vector of expressions in factory
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
* Example programs:
  - Parsing Json
  - Parsing Manglang
  - Raytracing
* Code formatting
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* vector math
  - Define add, sub, mul, div so that they only take two inputs that could be either list of numbers or number.
  - norms, dot, inner_products
* Generic programming
  - Generic container interface
    - Alternative syntax:
      - clear!list (bra)
      - new!list (bra)
      - remove!list jmf generic algorithms
      - empty!list
      - new@list
      - clone!list
      - copy!list
      - end@list (Compare end-keyword in while-loop)
      - last@list
      - sentinel@list
      - root@list
  - Describe ListBase as a "Concept".
* Rename to Mangelang?
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string
  - child@ as function that can be sent to map
  - Implement equal for dictionary
* Tools:
  - Command line interface for reading source from file and piping it to interpretor
  - Reformat to html with syntax high-lighting.
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition
* Is manglang suitable for numerical computations on arrays?
* Importing source files.
* Should setContext be run whenever we create a dict? Possible bug?
* Homepage
  - Syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  * Skill / level tree visualization for manglang syntax and taxonomy.
    - 8 bit or 16 bit icons.

* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}

* Remove python
* Problem with lookup of first and rest inside list environment 
{
  first = ...
  rest = ...
  result = f(first rest)
}
* Describe semantics of evaluation rules formaly as algebra.
* Meta language for describing semantic rules more formally?
* How would an implementation in modern c look?
  - Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ]
 https://www.youtube.com/watch?v=QpAhX-gsHMs&t=1775s
  - https://floooh.github.io/2019/09/27/modern-c-for-cpp-peeps.html
  - Pass by value everywhere. Can all pointers be pointers to constants so that everything is immutable?
  - Error handling - have a "valid" member variable in CodeRange to handle parse errors.
  - Memory ownership.
    - Have a global array for each type of expression.
    - Pass around indices to elements in it.
    - Re-allocate when runnig out of capacity.
    - Deallocate everything at the same time at the end of the program.
      No distinction between owning and non-owning pointers.
    - Store every value computed during the life-time of the program as immutable state.

* Pointers
  - Ownership model of raw and smart pointers in different passes.
  - When are nullpointers allowed?
  - Separate storage of parent and rest of node, for simple reseting of parent for lookups, without sacrificing immutability
  - How to represent the environment/parent tree during evaluation?
  - Parent is needed for lookup and apply.
    - Can we store the chain of parents locally when calling evaluate,
      instead of writing it to the tree?
    - When evaluating a functions we need to store its parent,
      so that we can later refer to the function from another place,
      and bind it to another name.

* Dynamic dictionaries
  - file and directory handling.
  - How to lookup a dynamic name in a dictionary?
  - How to define a dynamin name in a dictionary?
{
  x = "a"
  "x" = "a"
  x = a
  "x" = a
  x = x@dict
  x = x@@dict
  x = x<<dict
  x<= x<<dict
  name = <magnus
  name = "magnus"
}


EVALUATION EXAMPLES
{a = 0 b = a} -> {a = 0 b = 0}
a@{a = 0} -> 0
{f = in x out 0 g = f}         -> {f = in x out 0 g = ?} // Let it be undefined?
{f = in x out 0 a = f!1}       -> {f = in x out 0 a = 0}
{f = in x out 0 g = f!a = g!1} -> {f = in x out 0 g = ? a = 0}
{a = {a = 0 f = in x out a} g = f@a b = g!1} -> {a = {a = 0 f = in x out a} g = ? b = 1}
a@{apply=in(f x)out f!x g=in x out 0 a=apply!(g 1)}


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/
https://docs.scala-lang.org/tour/tour-of-scala.html

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = vÃ¤rde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number im:Number}
Complex : Type = {re:Number im:Number}
x : Distance = 3
square : Number = mul!(x x)

// primitive to primitive:
square : in x:Number out Number = mul!(x x)
square : x : Number -> Number = mul!(x x)
square : x : -> = mul!(x x)
square: = x: -> mul!(x x)
square = in x out mul!(x x)

// record to primitive:
hyp : in {x:Number y:Number} out Number = sqrt!add!(mul!(x x) mul!(y y))

// list to list:
conjugate : in x : List Number out List Number = (first@x neg!second!x)

// record to record:
conjugate : in {r:Number i:Number} out {r:Number i:Number} = {r := r i := neg!i}
conjugate : in Complex out Complex = {r := r i := neg!i}

// Type alias:
Complex : Type = {re:Number im:Number}
complex := {re := 1 im := 1}
complex : Complex = {re : Number = 1 im : Number = 1}
re = re@complex
im = im@complex
conjugate : in {r:Number i:Number} out {r:Number i:Number} = {r := r i := neg!i}
conjugate : in Complex out Complex = {r := r i := neg i}
complex2 = conjugate!complex1

// Generics:
max_value : in List!Generic out Generic = ...
max_index : in List!Generic out Number = ...
max_split : in List!Generic out List!List!Generic = ...

count_if : in {list: List!Generic predicate: in Generic out Boolean} out Number = ...
map: in {list: List!Generic0 operation: in Generic0 out Generic1} out List!Generic1 = ...
map2 : in {list0: List!Generic0 list1: List!Generic0 operation: in List!Generic0 out Generic1} out List!Generic1 = ...
map2heterogeneous : in {list0: List!Generic0 list1: List!Generic1 operation: in {value0: Generic0 value1: Generic1} out Generic2} out List!Generic2 = ...

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
âââ NUMBERS ââââ CHARACTERSââ
â 1           â 'a'         â
â 1.0         â 'b'         â
â -3.34       â 'c'         â
âââââââââââââââââââââââââââââ

ââ DICTIONARIES âââââââââââ STACKSââââââââââââ STRINGS âââââââ
â {NAME=EXPRESSION ...}  â (EXPRESSION ...) â "CHARACTER..." â
â                        â                  â                â
â {}                     â ()               â ""             â
â                        â                  â                â
â {width=320 height=240} â (1 2 3)          â "abc"          â
â                        â                  â                â
â {                      â (                â "Mang Lang"    â
â     x = 1              â     1            â                â
â     y = 2              â     2            â                â
â     z = 3              â     3            â                â
â }                      â )                â                â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

ââ REFERENCES âââââââââ CHILD REFERENCES ââââââââââââââââââ
â NAME               â NAME@EXPRESSION                    â
â                    â                                    â
â {                  â {                                  â
â     x = 1          â     rectangle = {width=1 height=2} â
â     y = x          â     w = width@rectangle            â
â     z = {a=1 b=y}  â     coordinate = z@{x=1 y=2 z=3}   â
â }                  â }                                  â
âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

âââ FUNCTION APPLICATION âââââââââââââââââââââ
â NAME!EXPRESSION                            â
â                                            â
â {                                          â
â     list = (1 2 3)                         â
â     num_elements = count!list              â
â     longer_list = put!(0 list)             â
â     backwards = reverse!"Mang Lang"        â
â     area = get_area!{width=320 height=240} â
â }                                          â
ââââââââââââââââââââââââââââââââââââââââââââââ

âââ CONDITIONALS âââââââââââââââââââââââââââââââââ ITERATIVE DICTIONARIES ââââââââââââââââââââââââââââââââ
â if EXPRESSION then EXPRESSION else EXPRESSION â {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} â
â                                               â                                                        â
â {                                             â {                                                      â
â     is_rich = 0                               â     sum = 0                                            â
â     money = if is_rich then 1000000 else 1    â     i = 10                                             â
â     list = ()                                 â     while i                                            â
â     is_list_empty = if list then 1 else 0     â         i = dec!i                                      â
â }                                             â         sum = add!(sum i)                              â
â                                               â     end                                                â
â                                               â }                                                      â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

âââ FUNCTIONS âââââââââââââââââââââââââââââââââââââââââ FUNCTIONS OF STACKS âââââââââââââ FUNCTIONS OF DICTIONARIES ââââââââââââââââ
â in NAME out EXPRESSION                            â in (NAME ...) out EXPRESSION    â in {NAME ...} out EXPRESSION               â
â                                                   â                                 â                                            â
â {                                                 â                                 â                                            â
â     square = in x out mul!(x x)                   â                                 â                                            â
â     nine = square 3                               â {                               â                                            â
â     square_norm2 = in vec out                     â     square_norm2 = in (x y) out â                                            â
â         add!(square!first!vec, square!second!vec) â         add!(square!x square!y) â                                            â
â     n = square_norm2!(3 4)                        â     n = square_norm2!(3 4)      â {                                          â
â     get_area = in shape out                       â     conj = in (re im) out       â     get_area = in {width height} out       â
â         mul!(width@shape height@shape)            â         (re neg!im)             â         mul!(width height)                 â
â     area = get_area!{width=320 height=240}        â     c = conj!(0 1)              â     area = get_area!{width=320 height=240} â
â }                                                 â }                               â }                                          â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

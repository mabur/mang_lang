TODO:
* Example programs:
  - Parsing Json
  - Parsing Manglang
  - Raytracing
* Code formatting
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* Fix sending built-in functions like prepend to higher order functions
* Convert functions from built-in to standard library.
  - fold_while
  - all, any, none, med och utan predikat
  - find_if, find_item, drop_item, drop_while...
  - split
  - trim
* Remove shared_ptr from linked list implementation.
  - Make CodeRange part of ExpressionPointer instead of expression.
* vector math
  - Define add, sub, mul, div so that they only take two inputs that could be either list of numbers or number.
  - norms, dot, inner_products
* Simplifications with new list:
  - Merge new list and new string?
  - Extract for_each for new lists and strings
  - resolve mutable pointer in iterative dictionary evaluation
  - remove shared_ptr from vector of expressions in factory
* Generic programming
  - Generic container interface
    - Alternative syntax:
      - clear!list (bra)
      - new!list (bra)
      - remove!list jmf generic algorithms
      - empty!list
      - new@list
      - clone!list
      - copy!list
      - end@list (Compare end-keyword in while-loop)
      - last@list
      - sentinel@list
      - root@list
  - Add second@, third@, fourth@, last@ ... members for lists and strings. _1st@string
    _1st, _2nd, _3rd, _4th, _5th, _6th, _7nth, _8th, _9th
  - Describe ListBase as a "Concept".
  - Naming of count_*, range, reverse_range, enumerate, new.
  - prepend. Let it be defined for arrays that have capacity and where the current reference is refering to the whole array and not a sub range. Otherwise run-time error.
* Rename to Mangelang?
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string
  - child@ as function that can be sent to map
  - Implement equal for dictionary
* Tools:
  - Command line interface for reading source from file and piping it to interpretor
  - Reformat to html with syntax high-lighting.
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition
* Is manglang suitable for numerical computations on arrays?
* Importing source files.
* Should setContext be run whenever we create a dict? Possible bug?
* parse and evaluate at the same time. One-pass / single pass.
  - Not good for reportring syntax errors and later on type errors.
* Implement interpretor executable and write all computed expressions to file for tracability and debugging.
* Homepage
  - Make logo: double lambda: https://docs.google.com/document/d/1QNm45cydqxuvMwjXDq3DtXoxuaiTAexnQ8VEtgLwjpM/edit
  - Improve home-page.
  - Prettier homepage.
  - Syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  * Skill / level tree visualization for manglang syntax and taxonomy.
    - 8 bit or 16 bit icons.
  - Write custom markup language for homepage that converts to html.
    Can contain manglang code which then gets syntax highlighted.
    Support images.
    Alternatively do everything in javascript?

* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}

* Remove python
* Problem with lookup of first and rest inside list environment 
{
  first = ...
  rest = ...
  result = f(first rest)
}
* Describe semantics of evluation rules formaly as algebra.
* Meta language for describing semantic rules more formally?
  - C with indices instead of pointers?
* How would an implementation in modern c look?
  - Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ]
 https://www.youtube.com/watch?v=QpAhX-gsHMs&t=1775s
  - https://floooh.github.io/2019/09/27/modern-c-for-cpp-peeps.html
  - Pass by value everywhere. Can all pointers be pointers to constants so that everything is immutable?
  - Error handling - have a "valid" member variable in CodeRange to handle parse errors.
  - Memory ownership.
    - Have a global array for each type of expression.
    - Pass around indices to elements in it.
    - Re-allocate when runnig out of capacity.
    - Deallocate everything at the same time at the end of the program.
      No distinction between owning and non-owning pointers.
    - Store every value computed during the life-time of the program as immutable state.
  - Generic algorithms?
    - What are the needs for the interpretor?

struct ExpressionPointer
{
  int type;
  size_t index;
};

struct Conditional
{
  ExpressionPointer expression_if;
  ExpressionPointer expression_then;
  ExpressionPointer expression_else;
};


* Implement list and string as syntactic sugar for dictionary {first=... rest={...}}
  - How to store efficiently? Use hash-function to go from string to number, so that we internally can store keys as numbers instead of strings.

* Pointers
  - Ownership model of raw and smart pointers in different passes.
  - When are nullpointers allowed?
  - Separate storage of parent and rest of node, for simple reseting of parent for lookups, without sacrificing immutability
  - How to represent the environment/parent tree during evaluation?
  - Parent is needed for lookup and apply.
    - Can we store the chain of parents locally when calling evaluate,
      instead of writing it to the tree?
    - When evaluating a functions we need to store its parent,
      so that we can later refer to the function from another place,
      and bind it to another name.

* Dynamic dictionaries
  - file and directory handling.
  - How to lookup a dynamic name in a dictionary?
  - How to define a dynamin name in a dictionary?
{
  x = "a"
  "x" = "a"
  x = a
  "x" = a
  x = x@dict
  x = x@@dict
  x = x<<dict
  x<= x<<dict
  name = <magnus
  name = "magnus"
}


EVALUATION EXAMPLES
{a = 0 b = a} -> {a = 0 b = 0}
a@{a = 0} -> 0
{f = in x out 0 g = f}         -> {f = in x out 0 g = ?} // Let it be undefined?
{f = in x out 0 a = f!1}       -> {f = in x out 0 a = 0}
{f = in x out 0 g = f!a = g!1} -> {f = in x out 0 g = ? a = 0}
{a = {a = 0 f = in x out a} g = f@a b = g!1} -> {a = {a = 0 f = in x out a} g = ? b = 1}
a@{apply=in(f x)out f!x g=in x out 0 a=apply!(g 1)}


SIMILAR LANGUAGES
* Lisp family
* Json
* Yaml
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* L1 https://mlajtos.github.io/L1/
* Azor: https://github.com/cstuartroe/azor
* Pico?
* CUE?
* GCL
* HCL?

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/
https://docs.scala-lang.org/tour/tour-of-scala.html

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = vÃ¤rde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number im:Number}
Complex : Type = {re:Number im:Number}
x : Distance = 3
square : Number = mul!(x x)

// primitive to primitive:
square : in x:Number out Number = mul!(x x)
square : x : Number -> Number = mul!(x x)
square : x : -> = mul!(x x)
square: = x: -> mul!(x x)
square = in x out mul!(x x)

// record to primitive:
hyp : in {x:Number y:Number} out Number = sqrt!add!(mul!(x x) mul!(y y))

// list to list:
conjugate : in x : List Number out List Number = (first@x neg!second!x)

// record to record:
conjugate : in {r:Number i:Number} out {r:Number i:Number} = {r := r i := neg!i}
conjugate : in Complex out Complex = {r := r i := neg!i}

// Type alias:
Complex : Type = {re:Number im:Number}
complex := {re := 1 im := 1}
complex : Complex = {re : Number = 1 im : Number = 1}
re = re@complex
im = im@complex
conjugate : in {r:Number i:Number} out {r:Number i:Number} = {r := r i := neg!i}
conjugate : in Complex out Complex = {r := r i := neg i}
complex2 = conjugate!complex1

// Generics:
max_value : in List!Generic out Generic = ...
max_index : in List!Generic out Number = ...
max_split : in List!Generic out List!List!Generic = ...

count_if : in {list: List!Generic predicate: in Generic out Boolean} out Number = ...
map: in {list: List!Generic0 operation: in Generic0 out Generic1} out List!Generic1 = ...
map2 : in {list0: List!Generic0 list1: List!Generic0 operation: in List!Generic0 out Generic1} out List!Generic1 = ...
map2heterogeneous : in {list0: List!Generic0 list1: List!Generic1 operation: in {value0: Generic0 value1: Generic1} out Generic2} out List!Generic2 = ...

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
âââ NUMBERS ââââ CHARACTERSââ
â 1           â 'a'         â
â 1.0         â 'b'         â
â -3.34       â 'c'         â
âââââââââââââââââââââââââââââ

ââ DICTIONARIES âââââââââââ LISTS ââââââââââââ STRINGS âââââââ
â {NAME=EXPRESSION ...}  â (EXPRESSION ...) â "CHARACTER..." â
â                        â                  â                â
â {}                     â ()               â ""             â
â                        â                  â                â
â {width=320 height=240} â (1 2 3)          â "abc"          â
â                        â                  â                â
â {                      â (                â "Mang Lang"    â
â     x = 1              â     1            â                â
â     y = 2              â     2            â                â
â     z = 3              â     3            â                â
â }                      â )                â                â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

ââ REFERENCES âââââââââ CHILD REFERENCES âââââââââââââââââââ
â NAME               â NAME@EXPRESSION                     â
â                    â                                     â
â {                  â {                                   â
â     x = 1          â     rectangle = {width=1 height=2}  â
â     y = x          â     w = width@rectangle             â
â     z = {a=1 b=y}  â     coordinate = z@{x=1 y=2 z=3}    â
â }                  â }                                   â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

âââ FUNCTION APPLICATION âââââââââââââââââââââ
â NAME!EXPRESSION                            â
â                                            â
â {                                          â
â     list = (1 2 3)                         â
â     num_elements = count!list              â
â     longer_list = prepend!(0 list)         â
â     backwards = reverse!"Mang Lang"        â
â     area = get_area!{width=320 height=240} â
â }                                          â
ââââââââââââââââââââââââââââââââââââââââââââââ

âââ CONDITIONALS âââââââââââââââââââââââââââââââââ ITERATIVE DICTIONARIES ââââââââââââââââââââââââââââââââ
â if EXPRESSION then EXPRESSION else EXPRESSION â {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} â
â                                               â                                                        â
â {                                             â {                                                      â
â     is_rich = 0                               â     sum = 0                                            â
â     money = if is_rich then 1000000 else 1    â     i = 10                                             â
â     list = ()                                 â     while i                                            â
â     is_list_empty = if list then 1 else 0     â         i = dec!i                                      â
â }                                             â         sum = add!(sum i)                              â
â                                               â     end                                                â
â                                               â }                                                      â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

âââ FUNCTIONS âââââââââââââââââââââââââââââââââââââââââ FUNCTIONS OF LISTS ââââââââââââââ FUNCTIONS OF DICTIONARIES ââââââââââââââââ
â in NAME out EXPRESSION                            â in (NAME ...) out EXPRESSION    â in {NAME ...} out EXPRESSION               â
â                                                   â                                 â                                            â
â {                                                 â                                 â                                            â
â     square = in x out mul!(x x)                   â                                 â                                            â
â     nine = square 3                               â {                               â                                            â
â     square_norm2 = in vec out                     â     square_norm2 = in (x y) out â                                            â
â         add!(square!first@vec, square!second!vec) â         add!(square!x square!y) â                                            â
â     n = square_norm2!(3 4)                        â     n = square_norm2!(3 4)      â {                                          â
â     get_area = in shape out                       â     conj = in (re im) out       â     get_area = in {width height} out       â
â         mul!(width@shape height@shape)            â         (re neg!im)             â         mul!(width height)                 â
â     area = get_area!{width=320 height=240}        â     c = conj!(0 1)              â     area = get_area!{width=320 height=240} â
â }                                                 â }                               â }                                          â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

TODO:
* Functions:
  - Math: trigonometry
  - Character: character_from_number, number_from_character, string_from_number, number_from_string, then to_upper, to_lower, is_alpha, is_digit.
  - child@ as function that can be sent to map
  - Implement equal for dictionary
  - rename functions first and rest to first! and rest! or get_first get_rest to not confuse noun/result from verb/function
  - Naming of count_*, range, reverse_range, enumerate.
* Error handling:
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Tools:
  - Command line interface for reading source from file and piping it to interpretor
  - Reformat to html with syntax high-lighting.
* Homepage
  - Make logo: double lambda: https://docs.google.com/document/d/1QNm45cydqxuvMwjXDq3DtXoxuaiTAexnQ8VEtgLwjpM/edit
  - Improve home-page.
  - Prettier homepage.
  - Syntax high-lighting.
* Skill tree visualization for manglang syntax and taxonomy.
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries. 
* Parser combinators
* Is manglang suitable for numerical computations on arrays?
* How to specify starting point for generic functions () and ""?
   - Have two versions of map? map_list and map_string, or list and string, or to_list and to_string
* Generic container interface
  - arrays. Let empty(x) give an empty array with same capacity as x.
  - prepend. Let it be defined for arrays that have capacity and where the current reference is refering to the whole array and not a sub range. Otherwise run-time error.
* Importing source files.

* Remove python

* Pointers
  - Ownership model of raw and smart pointers in different passes.
  - When are nullpointers allowed?
  - Separate storage of parent and rest of node, for simple reseting of parent for lookups, without sacrificinf immutability
  - How to represent the environment/parent tree during evaluation?
  - Parent is needed for lookup and apply.
    - Can we store the chain of parents locally when calling evaluate,
      instead of writing it to the tree?
    - When evaluating a functions we need to store its parent,
      so that we can later refer to the function from another place,
      and bind it to another name.

* Fix bug about captured variables that happens e.g. when calling map inside another function like in replace:
  y@{f=in (x,list) out map(in y out x, list), y=f(2,(0,0))}

  replace = in (old_item, new_item, list) out
        map(in item out if equal(item, old_item) then new_item else item, list),

EVALUATION EXAMPLES
{a = 0, b = a} -> {a = 0, b = 0}
a@{a = 0} -> 0
{f = in x out 0, g = f}          -> {f = in x out 0, g = ?} // Let it be undefined?
{f = in x out 0, a = f 1}        -> {f = in x out 0, a = 0}
{f = in x out 0, g = f, a = g 1} -> {f = in x out 0, g = ?, a = 0}
{a = {a = 0, f = in x out a}, g = f@a, b = g 1} -> {a = {a = 0, f = in x out a}, g = ?, b = 1}
a@{apply=in(f,x)out f x, g=in x out 0,a=apply(g,1)}


{
  list0 = ...,
  list1 = empty list0,
  tail = list0,
  while tail,
    list1 = prepend(first tail, list1),
    tail = rest tail,
  end
}

SIMILAR LANGUAGES
* Lisp family
* Json
* Yaml
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* L1 https://mlajtos.github.io/L1/
* Azor: https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


* Implement lists as dictionaries {first, rest} or {}?
  - functions first and rest can be replaced with member lookup first@ and rest@
  - prepend can be replaced with dict construction {first=first, rest=rest}
  - Can reverse be implemented in standard-library? yes, but I don't know if it can be made generic
  - How to differentiate between strings and lists?

    [] -> {type=list}
    [1] -> {first=1,rest={},type=list}
    [1,2] -> {first=1,rest={first=2,rest={},type=list},type=list}

    "" -> {type=character}
    "a" -> {first='a',rest={},type=list}
    "ab" -> {first='a',rest={first='b',rest={},type=list},type=list}

    {first=1,rest=[1,2], type=list}
    prepend{first=1,rest=[1,2]}
    list{first=1,rest=[1,2]}
    string{first='a',rest="bc"}


    How to serialize?
    - Have type field {type=character}
    - Have hidden type information
    How to store efficiently? No problem.
    - Use hash-function to go from string to number, so that we internally can store keys as numbers instead of strings.


TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = värde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number, im:Number}
Complex : Type = {re:Number, im:Number}
x : Distance = 3
square : Number = mul[x, x]

// primitive to primitive:
square : in x:Number out Number = mul[x, x]
square : x : Number -> Number = mul[x, x]
square : x : -> = mul[x, x]
square: = x: -> mul[x, x]
square = in x out mul[x, x]

// record to primitive:
hyp : in {x:Number, y:Number} out Number = sqrt add[mul[x, x], mul[y, y]

// list to list:
conjugate : in x : List Number out List Number = [first x, neg last x]

// record to record:
conjugate : in {r:Number, i:Number} out {r:Number, i:Number} = {r := r, i := neg i}
conjugate : in Complex out Complex = {r := r, i := neg i}

// Type alias:
Complex : Type = {re:Number, im:Number}
complex := {re := 1, im := 1}
complex : Complex = {re : Number = 1, im : Number = 1}
re = re complex
im = im complex
conjugate : in {r:Number, i:Number} out {r:Number, i:Number} = {r := r, i := neg i}
conjugate : in Complex out Complex = {r := r, i := neg i}
complex2 = conjugate complex1

// Generics:
max_value : in List Generic out Generic = ...
max_index : in List Generic out Number = ...
max_split : in List Generic out List List Generic = ...

count_if : in {list: List Generic, predicate: in Generic out Boolean} out Number = ...
map: in {list: List Generic0, operation: in Generic0 out Generic1} out List Generic1 = ...
map2 : in {list0: List Generic0, list1: List Generic0, operation: in List Generic0 out Generic1} out List Generic1 = ...
map2heterogeneous : in {list0: List Generic0, list1: List Generic1, operation: in {value0: Generic0, value1: Generic1} out Generic2} out List Generic2 = ...

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real, y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)


LEVELS
1. Data
   - numbers
   - characters
   - strings
   - lists
   - dictionaries
2. References
   - reference (substitution)
   - child reference (substitution)
3. Computation
   - if (substitution)
   - function definition
   - function call (substitution)
4. Imperative
   - while in dictionaries and updating of symbols (substitution)


Level 0    - Primitive data:       Numbers, Characters
Level 1    - Aggregate Data:       Lists, Strings, Dictionaries
Level 2    - References:           Reference, Child Reference
Level 3    - Branching:            Conditional
Level 4ai  - Function call:        Function call
Level 4aii - Functions definition: Function, (Function of List), (Function of Dictionary)
Level 4b   - Imperative:           Iterative dictionary

        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARACTERS═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ LISTS ════════════╔═ STRINGS ══════════╔═ DICTIONARIES ═════════╗
║ (EXPRESSION, ...)  ║ "CHARACTER..."     ║ {NAME=EXPRESSION, ...} ║
║                    ║                    ║                        ║
║ ()                 ║ ""                 ║ {}                     ║
║                    ║                    ║                        ║
║ (1,2,3)            ║ "abc"              ║ {width=320,height=240} ║
║                    ║                    ║                        ║
║ (                  ║ "Mang Lang"        ║ {                      ║
║     1,             ║                    ║     x = 1,             ║
║     2,             ║                    ║     y = 2,             ║
║     3              ║                    ║     z = 3              ║
║ )                  ║                    ║ }                      ║
╚════════════════════╚════════════════════╚════════════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ══════════════════╗
║ NAME               ║ NAME@EXPRESSION                     ║
║                    ║                                     ║
║ {                  ║ {                                   ║
║     x = 1,         ║     rectangle = {width=1,height=2}, ║
║     y = x,         ║     w = width@rectangle,            ║
║     z = {a=1, b=y} ║     coordinate = z@{x=1,y=2,z=3}    ║
║ }                  ║ }                                   ║
╚════════════════════╚═════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔══ FUNCTION APPLICATION ════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ NAME EXPRESSION                            ║
║                                               ║                                            ║
║ {                                             ║ {                                          ║
║     is_rich = 0,                              ║     list = (1, 2, 3),                      ║
║     money = if is_rich then 1000000 else 1,   ║     num_elements = count list,             ║
║     list = (),                                ║     longer_list = prepend(0, list),        ║
║     is_list_empty = if list then 1 else 0     ║     backwards = reverse "Mang Lang",       ║
║ }                                             ║     area = get_area{width=320, height=240} ║
║                                               ║ }                                          ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF LISTS ════════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME, ...) out EXPRESSION    ║ in {NAME, ...} out EXPRESSION              ║
║                                                   ║                                  ║                                            ║
║ {                                                 ║                                  ║                                            ║
║     square = in x out mul(x, x),                  ║                                  ║                                            ║
║     nine = square 3,                              ║ {                                ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x, y) out ║                                            ║
║         add(square first vec, square second vec), ║         add(square x, square y), ║                                            ║
║     n = square_norm2(3, 4),                       ║     n = square_norm2(3, 4),      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re, im) out       ║     get_area = in {width, height} out      ║
║         mul(width@shape, height@shape),           ║         (re, neg im),            ║         mul(width, height),                ║
║     area = get_area{width=320, height=240}        ║     c = conj(0, 1)               ║     area = get_area{width=320, height=240} ║
║ }                                                 ║ }                                ║ }                                          ║
╚═══════════════════════════════════════════════════╚══════════════════════════════════╚════════════════════════════════════════════╝

╔═ ITERATIVE DICTIONARIES ══════════════════════════════════╗
║ {NAME=EXPRESSION, while EXPRESSION, NAME=EXPRESSION, end} ║
║                                                           ║
║ {                                                         ║
║     sum = 0,                                              ║
║     i = 10,                                               ║
║     while i,                                              ║
║         i = dec i,                                        ║
║         sum = add(sum, i),                                ║
║     end                                                   ║
║ }                                                         ║
╚═══════════════════════════════════════════════════════════╝

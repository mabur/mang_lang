TODO:
* Current type checking approach:
  - Never annotate types.
  - Run type checking as mini-evaluation pass, without loops, that just evaluates the values of everything.
    - So variables can just store values, and every value has a type, just as in normal evaluation.
  - Do not support recursion.
  - No type inference, only evaluation/checking.
  - top@empty_stack gives type ANY.
  - Limit stacks to grow beyond 1, during type evaluation.
* Type checking and second empty stacks problem:
  - Evaluation of type of [[] [1]] and [[[]] [[1]]] etc.
  - Does not work well for concat![[] [1]] which is type-evaluated to concat![[]]
* Alternative 1: Type checking and empty stacks.
  - Accept that type evaluation does not handle all cases, and sometimes gives EMPTY/ANY.
  - Just handle so that it does not crash.
* Alternative 2: Type checking and empty stacks.
  - Somehow type-evaluate:
    - [[] [1]] to [[1]]
    - [[[]] [[1]]] to [[[1]]]
* Alternative 3: Type checking and empty stacks.
  - Add type annotation for empty stack:
    - [NUMBER] [[NUMBER]] [[[NUMBER]]]
    - <0> <<0>> <<<0>>>
    - <0> <[0]> <[[0]]>
    - [:0:] [:[:0:]:] [:[:[:0:]:]:]
    - clear![0] clear![[0]] clear![[[0]]]
    - stack!0 stack![0] stack![[0]]
    - Use special syntax for empty stacks with prototype inside it <0> [:0:] [>0<] [<0>]
    - clear![3] empty![3] stack!3, stack!NUMBER
  - How to define types for higher order functions that are defined as folds on empty stacks:
    - concat - probably ok
    - map
    - zip
    - consecutive_pairs
    - range - probably ok
* Type theory
  - How to check types for [1 2 \a 4]?
    - Do type checking at parse-time?
    - How to set the prototype value for the sentinel empty stack?
      - Can probably be done.
  - How to check types for [f!a g!b]?
  - Type checking for folds that transform input with empty stack as input: min, max, map:
    - Can the problem be avoided by not using fold?
    - Allow EMPTY as input for all built-in functions,
      - Only create EMPTY during evaluation of types but not evaluation of values?
      - Similar to null-pointer and billion-dollar mistake.
      - Numeric built-ins can return nan for EMPTY input.
      - Boolean/less/less_equal built-ins can return false for EMPTY input, similarly as for NAN.
  - Type checking for zip, which now uses a stack with elements of different types.
  - https://www.reddit.com/r/ProgrammingLanguages/comments/ss3w6n/an_accessible_introduction_to_type_theory_and/
  - https://mukulrathi.com/create-your-own-programming-language/intro-to-type-checking/
* Empty tuple () for MISSING, NULL.
* kebab-case
  - Numbers and -inf constant.
* Equality for dictionaries?
* Advent of code Needs
  * Look at advent of code 2021 day 10 for example of code with a bit of friction
    - Try to implement calculation of most common words in a text.
  * aoc algorithms in need:
    - sort
    - unique
    - not unique
    - Dynamic lookups of dictionary
    - Dynamic dictionaries/hash-maps/sets for unique-check
  * Dynamic dictionary keys, as a way to model sets and arrays.
    - Fix hacky implementation of get_names, that is not type safe, since it returns keys as strings Names but with '' inside the string, instead of as Labels.
    - Naming of dictionary functions:
      - get_names, get_index, get_keys, index, table of content, get_headings.
      - get_values
      - get_items
    - Built-in functions for checking if name is in dict: has?(name dictionary) contains?
    - "Evaluate" function as general solution that can be used to convert strings to names and general code.
    - Labels could be good for getter functions:
      getter = in label out in dictionary out get!(label dictionary)
      output = map!(getter!'member' input)
      - getter!'member' is similar to member@ if seen as a function
    - Are stacks still needed if we have dynamic dictionaries? What are they needed for?
  {
      N = 10
      result = {    
          i = 1
          while less?(i N)
              j = dec!i
              [i] = [j]
              i = inc!i
              key = (1 2)
              [key] = 1
              [(1 2)] = 1
          end
      }
      i = i@result
      j = j@result
      c = get!(2 result)
      d = get!(i result)
      e = get!(dec!N result)
      f = get!((1 2) result)
  }
  * Memory
    - 64 bit
    - Use less memory
* Split structs for evaluated and non-evaluated for:
  - Dictionaries (done)
  - Lists (done)
  - Functions (todo)
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
* Example programs:
  - Parsing Json
  - Parsing Manglang
  - Raytracing
* Code formatting
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* vector math
  - Define add, sub, mul, div so that they only take two inputs that could be either list of numbers or number.
  - norms, dot, inner_products
* Generic programming
  - Generic container interface
    - Alternative syntax:
      - clear!list (bra)
      - new!list (bra)
      - remove!list jmf generic algorithms
      - empty!list
      - clone!list
      - copy!list
      - end@list (Compare end-keyword in while-loop)
      - last@list
      - sentinel@list
      - root@list
  - Describe ListBase as a "Concept".
* Rename to Mangelang?
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string
* Tools:
  - Command line interface for reading source from file and piping it to interpretor
  - Reformat to html with syntax high-lighting.
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition
* Is manglang suitable for numerical computations on arrays?
* Importing source files.
* Homepage
  - Syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.

* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}

* Problem with lookup of first and rest inside list environment 
{
  first = ...
  rest = ...
  result = f(first rest)
}
* Describe semantics of evaluation rules formaly as algebra.
* Meta language for describing semantic rules more formally?
* How would an implementation in modern c look?
  - Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ]
 https://www.youtube.com/watch?v=QpAhX-gsHMs&t=1775s
  - https://floooh.github.io/2019/09/27/modern-c-for-cpp-peeps.html
  - Error handling - have a "valid" member variable in CodeRange to handle parse errors.


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/
https://docs.scala-lang.org/tour/tour-of-scala.html

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = vÃ¤rde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number im:Number}
Complex : Type = {re:Number im:Number}
x : Distance = 3
square : Number = mul!(x x)

// primitive to primitive:
square : in x:Number out Number = mul!(x x)
square : x : Number -> Number = mul!(x x)
square : x : -> = mul!(x x)
square: = x: -> mul!(x x)
square = in x out mul!(x x)

// record to primitive:
hyp : in {x:Number y:Number} out Number = sqrt!add!(mul!(x x) mul!(y y))

// list to list:
conjugate : in x : List Number out List Number = (first@x neg!second!x)

// record to record:
conjugate : in {r:Number i:Number} out {r:Number i:Number} = {r := r i := neg!i}
conjugate : in Complex out Complex = {r := r i := neg!i}

// Type alias:
Complex : Type = {re:Number im:Number}
complex := {re := 1 im := 1}
complex : Complex = {re : Number = 1 im : Number = 1}
re = re@complex
im = im@complex
conjugate : in {r:Number i:Number} out {r:Number i:Number} = {r := r i := neg!i}
conjugate : in Complex out Complex = {r := r i := neg i}
complex2 = conjugate!complex1

// Generics:
max_value : in List!Generic out Generic = ...
max_index : in List!Generic out Number = ...
max_split : in List!Generic out List!List!Generic = ...

count_if : in {list: List!Generic predicate: in Generic out Boolean} out Number = ...
map: in {list: List!Generic0 operation: in Generic0 out Generic1} out List!Generic1 = ...
map2 : in {list0: List!Generic0 list1: List!Generic0 operation: in List!Generic0 out Generic1} out List!Generic1 = ...
map2heterogeneous : in {list0: List!Generic0 list1: List!Generic1 operation: in {value0: Generic0 value1: Generic1} out Generic2} out List!Generic2 = ...

// Enklare alternativ - annotera bara definitioner av funktioner.

// primitive to primitive:
in Number : x out Number : mul!(x x)

// record to primitive:
in {Number : x Number : y} out Number : sqrt!add!(mul!(x x) mul!(y y))

// list to list:
in List!Number : x out List!Number : (first@x neg!second!x)

// record to record:
in {Number : r Number : i} out {Number : r Number : i} : {r := r i := neg!i}

// Generics:
max_value = in : list out ValueType!list : ...
max_index = in : list out Number : ...
count_if = in {: list in ValueType!list : item out Boolean : predicate} out Number : ...
map = in {: list in ValueType!list : item out : operation} out List!OutputType!operation : ...

// Generics:
max_value = in List : list out : ...
max_index = in List : list out Number : ...
count_if = in {List : list Function : predicate} out Number : ...
map = in {List : list Function : f} out : ...

// Ãnnu enklare alternativ - annotera ingenting men checka allt.


TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
âââ NUMBERS ââââ CHARACTERSââ
â 1           â 'a'         â
â 1.0         â 'b'         â
â -3.34       â 'c'         â
âââââââââââââââââââââââââââââ

ââ DICTIONARIES âââââââââââ STACKSââââââââââââ STRINGS âââââââ
â {NAME=EXPRESSION ...}  â (EXPRESSION ...) â "CHARACTER..." â
â                        â                  â                â
â {}                     â ()               â ""             â
â                        â                  â                â
â {width=320 height=240} â (1 2 3)          â "abc"          â
â                        â                  â                â
â {                      â (                â "Mang Lang"    â
â     x = 1              â     1            â                â
â     y = 2              â     2            â                â
â     z = 3              â     3            â                â
â }                      â )                â                â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

ââ REFERENCES âââââââââ CHILD REFERENCES ââââââââââââââââââ
â NAME               â NAME@EXPRESSION                    â
â                    â                                    â
â {                  â {                                  â
â     x = 1          â     rectangle = {width=1 height=2} â
â     y = x          â     w = width@rectangle            â
â     z = {a=1 b=y}  â     coordinate = z@{x=1 y=2 z=3}   â
â }                  â }                                  â
âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

âââ FUNCTION APPLICATION âââââââââââââââââââââ
â NAME!EXPRESSION                            â
â                                            â
â {                                          â
â     list = (1 2 3)                         â
â     num_elements = count!list              â
â     longer_list = put!(0 list)             â
â     backwards = reverse!"Mang Lang"        â
â     area = get_area!{width=320 height=240} â
â }                                          â
ââââââââââââââââââââââââââââââââââââââââââââââ

âââ CONDITIONALS âââââââââââââââââââââââââââââââââ ITERATIVE DICTIONARIES ââââââââââââââââââââââââââââââââ
â if EXPRESSION then EXPRESSION else EXPRESSION â {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} â
â                                               â                                                        â
â {                                             â {                                                      â
â     is_rich = 0                               â     sum = 0                                            â
â     money = if is_rich then 1000000 else 1    â     i = 10                                             â
â     list = ()                                 â     while i                                            â
â     is_list_empty = if list then 1 else 0     â         i = dec!i                                      â
â }                                             â         sum = add!(sum i)                              â
â                                               â     end                                                â
â                                               â }                                                      â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

âââ FUNCTIONS âââââââââââââââââââââââââââââââââââââââââ FUNCTIONS OF STACKS âââââââââââââ FUNCTIONS OF DICTIONARIES ââââââââââââââââ
â in NAME out EXPRESSION                            â in (NAME ...) out EXPRESSION    â in {NAME ...} out EXPRESSION               â
â                                                   â                                 â                                            â
â {                                                 â                                 â                                            â
â     square = in x out mul!(x x)                   â                                 â                                            â
â     nine = square 3                               â {                               â                                            â
â     square_norm2 = in vec out                     â     square_norm2 = in (x y) out â                                            â
â         add!(square!first!vec, square!second!vec) â         add!(square!x square!y) â                                            â
â     n = square_norm2!(3 4)                        â     n = square_norm2!(3 4)      â {                                          â
â     get_area = in shape out                       â     conj = in (re im) out       â     get_area = in {width height} out       â
â         mul!(width@shape height@shape)            â         (re neg!im)             â         mul!(width height)                 â
â     area = get_area!{width=320 height=240}        â     c = conj!(0 1)              â     area = get_area!{width=320 height=240} â
â }                                                 â }                               â }                                          â
ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

TODO:
https://www.reddit.com/r/ProgrammingLanguages/comments/ugysu5/functional_language_for_data_descriptionconfig/
* Document table functions.
* Type checking for tables.
  - Enforce homogenous keys and values for type checking. Unlike dictionaries that have homogeneous keys/labels but heterogenous values.
* Nils says that quasiquote and unquote and quote in racket could be a nice fit for manglang and vice versa, for macros and meta-programming.
  - Could add two operations and keywords: evaluate and anti-evaluate/devaluate/integrate/pass/ignore/skip/preserve
  - Let them have the semantics:
    evaluate preserve expression -> expression
  - "Evaluate" function as general solution that can be used to convert strings to names and general code, e.g. for parsing json.
* Tools:
  - Type checking.
  - Command line interface for reading source from file and piping it to interpretor
* Code formatting
  - Indentaiton and line breaks.
  - Colors and syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  - Homepage
* Advent of code Needs
  * Look at advent of code 2021 day 10 for example of code with a bit of friction
    - Try to implement calculation of most common words in a text.
  * Memory
    - 64 bit
    - Use less memory
* Example programs:
  - Parsing Json
  - Parsing Manglang
  - Raytracing
* Memory management.
* Built-in functions for checking if name is in dict: has?(name dictionary) contains? inside?
* Empty tuple () for MISSING, NULL.
* kebab-case
  - Numbers and -inf constant.
* Equality for dictionaries?
* Split structs for evaluated and non-evaluated for:
  - Dictionaries (done)
  - Lists (done)
  - Tables (done)
  - Functions (todo)
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* Is manglang suitable for numerical computations on arrays?
* vector math
  - Define add, sub, mul, div so that they only take two inputs that could be either list of numbers or number.
  - norms, dot, inner_products
* Generic programming
  - Generic container interface.
  - Describe ListBase as a "Concept".
* Rename to Mangelang?
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition
* Importing source files.
* Documentation and specification. Describe the steps and rules more formally, in metalanguage or graphical.
  - Parsing: manglang code -> tree. (EBNF, railroad diagrams)
  - Serializing: tree -> manglang code. (EBNF?, same as above?)
  - Evaluation: tree -> tree. (graphical nodes? algebra)

* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}

* Problem with lookup of first and rest inside list environment 
{
  first = ...
  rest = ...
  result = f(first rest)
}


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/

* (Cognate read) https://github.com/cognate-lang/cognate

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/
https://docs.scala-lang.org/tour/tour-of-scala.html

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARACTERS═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ DICTIONARIES ═════════╔═ STACKS══════════╔═ STRINGS ══════╗
║ {NAME=EXPRESSION ...}  ║ (EXPRESSION ...) ║ "CHARACTER..." ║
║                        ║                  ║                ║
║ {}                     ║ ()               ║ ""             ║
║                        ║                  ║                ║
║ {width=320 height=240} ║ (1 2 3)          ║ "abc"          ║
║                        ║                  ║                ║
║ {                      ║ (                ║ "Mang Lang"    ║
║     x = 1              ║     1            ║                ║
║     y = 2              ║     2            ║                ║
║     z = 3              ║     3            ║                ║
║ }                      ║ )                ║                ║
╚════════════════════════╚══════════════════╚════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ═════════════════╗
║ NAME               ║ NAME@EXPRESSION                    ║
║                    ║                                    ║
║ {                  ║ {                                  ║
║     x = 1          ║     rectangle = {width=1 height=2} ║
║     y = x          ║     w = width@rectangle            ║
║     z = {a=1 b=y}  ║     coordinate = z@{x=1 y=2 z=3}   ║
║ }                  ║ }                                  ║
╚════════════════════╚════════════════════════════════════╝

╔══ FUNCTION APPLICATION ════════════════════╗
║ NAME!EXPRESSION                            ║
║                                            ║
║ {                                          ║
║     list = (1 2 3)                         ║
║     num_elements = count!list              ║
║     longer_list = put!(0 list)             ║
║     backwards = reverse!"Mang Lang"        ║
║     area = get_area!{width=320 height=240} ║
║ }                                          ║
╚════════════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔═ ITERATIVE DICTIONARIES ═══════════════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} ║
║                                               ║                                                        ║
║ {                                             ║ {                                                      ║
║     is_rich = 0                               ║     sum = 0                                            ║
║     money = if is_rich then 1000000 else 1    ║     i = 10                                             ║
║     list = ()                                 ║     while i                                            ║
║     is_list_empty = if list then 1 else 0     ║         i = dec!i                                      ║
║ }                                             ║         sum = add!(sum i)                              ║
║                                               ║     end                                                ║
║                                               ║ }                                                      ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF STACKS ══════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME ...) out EXPRESSION    ║ in {NAME ...} out EXPRESSION               ║
║                                                   ║                                 ║                                            ║
║ {                                                 ║                                 ║                                            ║
║     square = in x out mul!(x x)                   ║                                 ║                                            ║
║     nine = square 3                               ║ {                               ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x y) out ║                                            ║
║         add!(square!first!vec, square!second!vec) ║         add!(square!x square!y) ║                                            ║
║     n = square_norm2!(3 4)                        ║     n = square_norm2!(3 4)      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re im) out       ║     get_area = in {width height} out       ║
║         mul!(width@shape height@shape)            ║         (re neg!im)             ║         mul!(width height)                 ║
║     area = get_area!{width=320 height=240}        ║     c = conj!(0 1)              ║     area = get_area!{width=320 height=240} ║
║ }                                                 ║ }                               ║ }                                          ║
╚═══════════════════════════════════════════════════╚═════════════════════════════════╚════════════════════════════════════════════╝

* Add type checking gradually, by addint it to the tests gradually, by adding test.check_and_evaluate and gradually replace test.evaluate.
TODO Standard Library:
* Indexing
  - Allow both container!index and index!container. Second version is good for multiple indexing of images x!y!image.
  - What about tables? When to return key-value-tuple and when to just return value?
    - get0,..., can already be used for tables. Mirror that behaviour.
    - table!index (make constant or logN?)
    - get!(key table default_value) (logN)
* Elementwise arithmetic for more convenient vector math. See aoc_22_09.
* all_of, any_of, none_of
  - add generic map that requires that f has same input and output type,
    so that it does not change type of the container.
    Then the same map could be used for stack, string, table.
    That map could be used instead of replace_*.
* Interface for containers:
  - Define and & or on tuples/pairs instead of stacks.
  - add empty? is_empty? function for containers?
    - Makes even more sense after for-loops are added.
    - nonempty, is_not_empty? populated, inhabited
    - empty = in container out is container
        [] then true
        "" then true
        <> then true
        0 then true
        else false
  - Compare interface for iterating over containers and numbers:
    - take!container, 1, ?
    - drop!container, dec!number
    - put!(item container), add!(1 number), inc!number
    - empty
    - clear!container, [], "", <>, 0
    - put!(take!x drop!x) == x, add!(1 dec!x) == x
    - ett positivt heltal är ekvivalent med en stack, där bara längden på stacken spelar roll, men inte innehållet.
    - sub!(a b) == take_n!(count!b a)
    - mul!(a b) == cartesian product?
    - div?
    - inc?
    - reverse!number == number
    - put_each!(a b) == add!(a b)
    - make_number!container == count!container
    - merge_stack!(a b) == sum_stack!(a b)
    - map_number!(f number) == sum_N f(n)
    - sum![numbers] == merge_stacks![stacks]
    - product![numbers] == cartesian product?
  - get vs indexing
    - Replace get!(key table default_value) for tables with container!key?
    - O(N) for stack and string
    - O(1) for table
  - count!containers
    - O(N) for stack and string
    - O(1) for table
  - Built-in functions for checking if name is in dict: has?(name dictionary) contains? inside?
    - O(N) for stack and string
    - O(1) for table
  - add higher_order function that takes a unary function and constructs a new binary function
    that applies identity to first argument, so that it can be used for table pairs of (key value).
  - add higher_order function that takes a unary predicate and constructs a new binary predicate
    that ignores the first argument, so that it can be used for table pairs of (key value).
  - Compare algorithms with those in libraries like: https://github.com/samber/lo
* Add unordered/reversed versions of algorithms like map, clear_if, replace_if etc.
  - Let unordered be default since it makes sense for both stacks and tables.
  - clear_if_ordered, map_ordered.
* Vector math. Is manglang suitable for numerical computations on arrays?
  - Define add, sub, mul, div so that they only take two inputs that could be either list of numbers or number.
  - norms, dot, inner_products
* Functions:
  - Math: trigonometry
  - Character: string_from_number, number_from_string

TODO Tools:
* Type checking from command line.
* Command line interface for reading source from file and piping it to interpretor
* Code formatting
  - Indentaiton and line breaks.
  - Colors and syntax high-lighting.
  - Implement tool that takes a source file and outputs an html.
  - Homepage
* Web interpreter using wasm.

TODO example programs:
* Raytracing
* Parsing Json
* Parsing Manglang
* Advent of code

TODO Language:
* Extend while statements with for statements and if statements.

container = ...
while container
  item = take!container
  ...
  container = drop!container
end

// Most convenient for programmer, but extra complexity to implement initialization before loop starts running the first time.
for item in [1 2 3]
  ...
end

// Less convenient, but no special initialization needed.
container = [1 2 3]
for item in container
  ...
end

  - If drop is implemented for numbers then we can do both:
    for item in range!10 -> 0,1,2,3,4,5,6,7,8,9
    for i in 10 -> 10,9,8,7,6,5,4,3,2,1
  - Could have syntax that shows that both the name of the item and the container is added to the dictionary:
    for item in container as expression
    for item in container from expression
    for item, container in expression
    for item in container = expression
    container = expression for item in container
  - Could alternatively require that item is a new name and container is an existing name:
    for item in container
  - Implement more control structures like for & if by first refactoring dictionary statements,
    so that we can have hierarchical groups of statements corresponding to "scope".
  - Support index in for loop:
    for index, item in container
* Add syntactic sugar for put:
  table += (k v)
  container += item
  container << item Ruby
  container ..= item Lua
  container .= item Perl PHP
  container ,= item
* Does not work for aoc22_12_07, since then the name is first used for the input and then shadowed by usage in the dictionary.
* Add syntactic sugar for numbers +=, -=.
  += could potentially be implemented by extending "put" to numbers.
* (Add syntactic sugar for drop):
  container -=
  container >>
  container--
* If-expression with multiple branches without "else if" nesting:
    if
      a then b
      c then e
      else f
* Conditional return statements for dictinary
    return if a
* If statements for dictionaries.
    if a
      b = c
    end
* Nodes & Passes:
  - Parse
    - serialize
    - evaluate_types
      - serialize_types
    - evaluate
      - serialize
* Better error messages:
  - Always run type checking for better error messages.
* How to solve aoc_22_13 if type checking would enforce homogeneous stacks?
  - Isinstance
  - Inheritance/polymorphism
  - Run-time-dispatch
  - Sum-type/choice-type
* Type "assertions".
  - For what cases?
    - any concrete function (simple and pretty)
    - any function
    - any concrete symbol
    - any symbol
    - any concrete expression
    - any expression
  - TypePredicates:
    - number, function, container, 
    - TypeFunctions can take a function and return another function
      - optional!number, variant![number character], container!number, function!(a b), tuple!(number character)
      - How to handle lazy evaluation for optional and variant?
        - Add general lazy/shortcut or operator?
  - Type annotations vs simple inference from code?
    - Could let the type checker/inferer automatically add it to the code or to the editor.
    - Could support both options and gradual typing.
  - static assertions
  - static_assert!equal?(x Number)
  - static_assert!any?[equal?(x Number) equal?(x Character)]
  - is_string = in s out equal?(take!name@d Character)
  - in d out all?[is_string?name@d is_number?age@d]
  - Assert as general expression or statement in dict?
    - Just for input and output of functions, or any symbol or any expression?
    - Expression:
      - x = check!(x is_number)
    - Statement:
      in (a b c) out {
        is_number?x
        is_variant3?(b [is_number is_character is_boolean])
        is_number?(take!c is_number)
        is_container?(c)
      }
      square = in x out mul!(x x)
      square = in number : x out number : mul!(x x)    (bra)
      square = in x out number : mul!(number : x x)
      square = in x out check!(number mul!(check!(number x) x))
      square = in x out check!(number result@{
          x = check!(number x)
          result = mul!(x x)
        }
      )
* James Gosling: "jvm bytecode as syntax tree in reverse polish notation".
  - Think of input and output of bytecode interpreter as flattened and efficient tree representation.
  - Compare iterators over an array.
* https://www.reddit.com/r/ProgrammingLanguages/comments/ugysu5/functional_language_for_data_descriptionconfig/
* Data & code in multiple files:
  - Importing source files.
  - Reading text file. Interpret text file as manglang source, but surround it with "" to make a string.
* Add short-circuit "and" "or" to while statement.
* Type checking for tables.
  - Enforce homogenous keys and values for type checking. Unlike dictionaries that have homogeneous keys/labels but heterogenous values.
* Change syntax for tables from <a:b c:d> to <(a b) (c d)>.
* Stack and table comprehension and fold/reduction?
* Ranges. Store both stacks and tables as ranges.
  - Is it safe for stacks and tables, as long as we only do insertion but not erasure of the shared storage?
  - Or at least as long as we do not mutate while iterating.
  - https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers
* Persistent hash map like in Clojure. Array mapped hash tries (Bagwell: non-persistent, Rich Hickey: persistent).
  - HAMT - Hash Array Mapped Tries.
  - When making copies, it creates new nodes for the path from the root to the leaf, and shares the rest.
* Nils says that quasiquote and unquote and quote in racket could be a nice fit for manglang and vice versa, for macros and meta-programming.
  - Could add two operations and keywords: evaluate and anti-evaluate/devaluate/integrate/pass/ignore/skip/preserve
  - Let them have the semantics:
    evaluate preserve expression -> expression
  - "Evaluate" function as general solution that can be used to convert strings to names and general code, e.g. for parsing json.
* Advent of code Needs
  * Look at advent of code 2021 day 10 for example of code with a bit of friction
    - Try to implement calculation of most common words in a text.
  * Memory
    - 64 bit
    - Use less memory
* Memory management.
* Empty tuple () for MISSING, NULL.
* kebab-case
  - Numbers and -inf constant.
* Equality for dictionaries?
* Split structs for evaluated and non-evaluated for:
  - Dictionaries (done)
  - Lists (done)
  - Tables (done)
  - Functions (todo)
* Error handling:
  - Output logs
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
  - Better error messages
  - Tests for syntax error and run-time error.
* Fix FunctionDictionary closure
* Rename to Mangelang?
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries.
* Subsets of manglang:
  - Data: number, character, dictionaries, list, string
  - Minimal computation: number, dictionaries, references, child references, function application, function definition

* Documentation and specification. Describe the steps and rules more formally, in metalanguage or graphical.
  - Parsing: manglang code -> tree. (EBNF, railroad diagrams)
  - Serializing: tree -> manglang code. (EBNF?, same as above?)
  - Evaluation: tree -> tree. (graphical nodes? algebra)

* Oding keyword "using" for unpacking dictionary into dictionary.
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {using size using point}

  using std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  using max_element!(3 7 6)
}
{
  size = {width=320 height=240}
  point = {x=10 y=20}
  rect = {unpack size unpack point}
  
  unpack std

  max_element = in list out {value = ... index = ...}
  result = max_element!(3 7 6)
  value = value@result
  index = index@result
  // Alternative
  unpack max_element!(3 7 6)
}


SIMILAR LANGUAGES
* Lisp family: https://en.wikipedia.org/wiki/Lisp_(programming_language)
* Json: https://www.json.org/

* Nix https://nixos.wiki/wiki/Overview_of_the_Nix_Language
* HCL / Terraform language https://github.com/hashicorp/hcl https://www.terraform.io/language
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* CUE https://cuelang.org/
* GCL https://gcl.readthedocs.io/

* L1 https://mlajtos.github.io/L1/
* Sprylang http://sprylang.se/manual.html#composites

* (Cognate read) https://github.com/cognate-lang/cognate

* (Yaml)
* (TOML) https://github.com/toml-lang/toml
* (Lua) https://www.lua.org/
* (Pico) http://pico.vub.ac.be/
* (Azor) https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/
https://docs.scala-lang.org/tour/tour-of-scala.html

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


LEVELS
1. Data
  - Atoms
      - numbers
      - characters
  - Containers
    - strings
    - lists
    - dictionaries
2. Data References
  - reference (substitution)
  - child reference (substitution)
3. Control flow (turing complete)
  - Conditional if (substitution)
  - Iterative dictionary, while in dictionaries and updating of symbols (substitution)
4. Function application (substitution)
5. Function Definition
  - Function
  - Function of list
  - Function of dictionary

When evaluating level 1-4 the result is level 1.
When evaluating level 5 the result is level 5.

Have different levels per file, so that the functions can be in one file
and then the result file can import them and evaluate its result to level 1.


SUB LANGUAGES
* Json-like: level 1
* Yaml-like: level 2
* Turing complete: level 3
* Non-turing complete calculator: level 1,2,4
* Full: level 5
* Minimal computation: numbers & dictionaries & References & Control flow


        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARACTERS═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ DICTIONARIES ═════════╔═ STACKS══════════╔═ STRINGS ══════╗
║ {NAME=EXPRESSION ...}  ║ (EXPRESSION ...) ║ "CHARACTER..." ║
║                        ║                  ║                ║
║ {}                     ║ ()               ║ ""             ║
║                        ║                  ║                ║
║ {width=320 height=240} ║ (1 2 3)          ║ "abc"          ║
║                        ║                  ║                ║
║ {                      ║ (                ║ "Mang Lang"    ║
║     x = 1              ║     1            ║                ║
║     y = 2              ║     2            ║                ║
║     z = 3              ║     3            ║                ║
║ }                      ║ )                ║                ║
╚════════════════════════╚══════════════════╚════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ═════════════════╗
║ NAME               ║ NAME@EXPRESSION                    ║
║                    ║                                    ║
║ {                  ║ {                                  ║
║     x = 1          ║     rectangle = {width=1 height=2} ║
║     y = x          ║     w = width@rectangle            ║
║     z = {a=1 b=y}  ║     coordinate = z@{x=1 y=2 z=3}   ║
║ }                  ║ }                                  ║
╚════════════════════╚════════════════════════════════════╝

╔══ FUNCTION APPLICATION ════════════════════╗
║ NAME!EXPRESSION                            ║
║                                            ║
║ {                                          ║
║     list = (1 2 3)                         ║
║     num_elements = count!list              ║
║     longer_list = put!(0 list)             ║
║     backwards = reverse!"Mang Lang"        ║
║     area = get_area!{width=320 height=240} ║
║ }                                          ║
╚════════════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔═ ITERATIVE DICTIONARIES ═══════════════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ {NAME=EXPRESSION while EXPRESSION NAME=EXPRESSION end} ║
║                                               ║                                                        ║
║ {                                             ║ {                                                      ║
║     is_rich = 0                               ║     sum = 0                                            ║
║     money = if is_rich then 1000000 else 1    ║     i = 10                                             ║
║     list = ()                                 ║     while i                                            ║
║     is_list_empty = if list then 1 else 0     ║         i = dec!i                                      ║
║ }                                             ║         sum = add!(sum i)                              ║
║                                               ║     end                                                ║
║                                               ║ }                                                      ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF STACKS ══════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME ...) out EXPRESSION    ║ in {NAME ...} out EXPRESSION               ║
║                                                   ║                                 ║                                            ║
║ {                                                 ║                                 ║                                            ║
║     square = in x out mul!(x x)                   ║                                 ║                                            ║
║     nine = square 3                               ║ {                               ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x y) out ║                                            ║
║         add!(square!vec!0, square!vec!1)          ║         add!(square!x square!y) ║                                            ║
║     n = square_norm2!(3 4)                        ║     n = square_norm2!(3 4)      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re im) out       ║     get_area = in {width height} out       ║
║         mul!(width@shape height@shape)            ║         (re neg!im)             ║         mul!(width height)                 ║
║     area = get_area!{width=320 height=240}        ║     c = conj!(0 1)              ║     area = get_area!{width=320 height=240} ║
║ }                                                 ║ }                               ║ }                                          ║
╚═══════════════════════════════════════════════════╚═════════════════════════════════╚════════════════════════════════════════════╝

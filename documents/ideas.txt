TODO:
* Functions:
  - Math: ceil/round_up, floor/round_down, round
  - Character: to_upper, to_lower, is_alpha, is_digit, to_number, to_ascii
  - child@ as function that can be sent to map
  - Implement equal for dictionary
  - rename functions first and rest to first! and rest! to not confuse noun/result from verb/function
  - Naming of count_*, range, reverse_range, enumerate.
* Error handling:
  - Make "1 2" throw a parse error
  - c++ add systematic error messages when parsing fails
    - Print all sub-expressions that it parsed
* Command line interface for reading source from file and piping it to interpretor
* Homepage
  - Make logo: double lambda: https://docs.google.com/document/d/1QNm45cydqxuvMwjXDq3DtXoxuaiTAexnQ8VEtgLwjpM/edit
  - Improve home-page.
  - Prettier homepage.
  - Syntax high-lighting.
* Skill tree visualization for manglang syntax and taxonomy.
* Can expression trees be implemented more like values and less like pointers? More like lisp?
https://www.reddit.com/r/ProgrammingLanguages/comments/mdtdxq/unifying_objects_and_scopes/
* Imperative Support
  - Redefinition of symbols in dictionaries
  - while in dictionaries
  - only support mutation of symbols in current dictionary
  - avoid global mutable state
  - hides mutation, so that each unit is pure from the outside
  - do not allow other side-effects
* Implement everything needed to convert between json and manglang in manglang.
  - Dynamic creation of dictionaries. 
* Not turing complete
  - Remove recursion and replace with map/filter/fold/list-comprehension/sql
* higher order function for for-loop, that can be used instead of recursion for long lists
 - iterate{start=1, while=p, update=f}
 - operator:
    iterate "start" while "while" update "update"
    iterate "start" by "update" while "while"
    iterate "start" to "update" while "while"
    iterate "start" with "update" while "while"
    for "start" while "while" update "update"
 - function comprehension:
    in ... out ... while ...
    iterate ... out ... while ...
    repeat ... out ... while ...
    iterate ... while ...
 - fold
 - How to specify starting point for generic functions () and "", when not using recursion?
   - Return input if empty otherwise start with first element instead of empty element? Would that work?
   - have empty function?
* Parser combinators
* Tail call optimization.
* Mutable dictionary definition

count = in list out (if list then (inc (count (rest (list)))) else 0)

// Parsed:
{
sum = 0,
y = 0,
x = 0,
while less(y, 240),
  x = 0,
  while less(x, 320),
    sum = add(sum, x, y),
    x = inc x,
  end,
  y = inc y,
end,
result = square sum
}
// Evaluated:
{
sum = ?,
y = 240,
x = 320,
result = ?
}
// Evaluated with constants such that loops are skipped:
{
sum = 0,
y = 0,
x = 0,
result = 0
}
Iterera igenom den parsade dictionaryn.
for (auto it = elements.begin(); it != elements.end(); it = (*it)->update(evaluated, it)){
}

* Kalla på: (*element)->update(evaluated, element)
  - För en vanlig så evaluerar den value och lägger till den till key, om den inte finns, eller uppdaterar key om den finns.
    Vilket interface vill man ha för detta?
    Hur ska man göra för att det ska vara effektivt att både hitta en key och hoppa för while och end?
    Förberäkna vart man ska hoppa till när man parsar.
    - Kanske behöver en EmptyNode också, ifall ett namn förekommer innuti en while men aldrig evalueras, vilket man inte vet i förväg.
    - Alternativt lägga till ett undefined/null/none värde som default i dicten.
    - Alternativt kräva att alla initieras utanför while, före eller efter, dvs att innuti while sker bara mutation av tidigare definierade och ingen definition. Ok att definiera efteråt.
    Den gör ++parsed_iterator
  - För en end så subtraherar den parsed_iterator tills man kommer till motsvarande while
  - För while så evaluerar den predicate.
    Om det är sant så ++parsed_iterator,
    annars ger adderar den parsed_iterator till man kommer till motsvarande end
* Implementera som DictionaryElementBase:
  - ElementDefinition
  - ElementMutation
  - While
  - End
* Efter evaluering så har man bara kvar ElementDefinition.
* Splitta upp Dictionary så att det finns en Dictionary, som bara har ElementDefinition, och en DictionaryLoop, som kan ha alla.
  Evaluering av en DictionaryLoop ger en vanlig Dictionary. Detta borde koppla isär den komplicerade logiken.


LEVELS
1. Data
   - numbers
   - characters
   - strings
   - lists
   - dictionaries
2. References
   - reference (substitution)
   - child reference (substitution)
3. Computation
   - if (substitution)
   - function definition
   - function call (substitution)
4. Imperative
   - while in dictionaries and updating of symbols (substitution)

SIMILAR LANGUAGES
* Lisp family
* Json
* Yaml
* Jsonnet https://jsonnet.org/
* Dhall https://dhall-lang.org/
* L1 https://mlajtos.github.io/L1/
* Azor: https://github.com/cstuartroe/azor

WEBPAGE
https://www.passerine.io/
https://nim-lang.org/
https://github.com/tuqqu/oxide-lang
https://www.pyret.org/

Languages supported by Github:
https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
Candidates:
HiveQL


iterate = in {start, update, while} out 
    if while start then
        iterate {start = update start, update = update, while = while}
    else
        init
// Higher order function:
factorial = in x out product@{
    update = in {product, x} out {product = mul [product, x], i = dec x},
    while = in {x} out not equal [x, 1],
    product = produxct@iterate{start = {product = 1, x = x}, update = update, while = while} 
}
// Operator:
factorial = in x out product@
    iterate {product = 1, x = x}
    out {product = mul [product, x], x = dec x}
    while not equal [x, 1]
// Function comprehension:
factorial = in x out product@{
    f = in {product, x} out {product = mul [product, x], x = dec x} while not equal [x, 1]
    product = f {product=1, x=x}
}
// Function comprehension alternative:
factorial = in x out product@{
    f = iterate {product = mul [product, x], x = dec x} while not equal [x, 1]
    product = f {product=1, x=x}
}
// Recursion:
count = in list out
    if list then
        inc count rest list
    else
        0,
// Operator:
count = in list out count@
    iterate {count=0, list=list}
    out {count = inc count, list = rest list}
    while list
// Mutable dictionaries:
count = in list out result@{
  result = 0,
  tail = list,
  while tail,
    result = inc result,
    tail = rest tail,
  end
}
// Operator:
reverse = in list out new_list@
    iterate {new_list = empty(list), tail = list}
    out {new_list = prepend(first tail, new_list), tail = rest tail}
    while tail
// Mutable dictionaries:
reverse = in list out new_list@{
    new_list = empty(list),
    tail = list,
    while tail,
      new_list = prepend(first tail, new_list),
      tail = rest tail,
    end
}


* Implement lists as dictionaries {first, rest} or {}?
  - functions first and rest can be replaced with member lookup first@ and rest@
  - prepend can be replaced with dict construction {first=first, rest=rest}
  - Can reverse be implemented in standard-library? yes, but I don't know if it can be made generic
  - How to differentiate between strings and lists?

    [] -> {type=list}
    [1] -> {first=1,rest={},type=list}
    [1,2] -> {first=1,rest={first=2,rest={},type=list},type=list}

    "" -> {type=character}
    "a" -> {first='a',rest={},type=list}
    "ab" -> {first='a',rest={first='b',rest={},type=list},type=list}

    {first=1,rest=[1,2], type=list}
    prepend{first=1,rest=[1,2]}
    list{first=1,rest=[1,2]}
    string{first='a',rest="bc"}


    How to serialize?
    - Have type field {type=character}
    - Have hidden type information
    How to store efficiently? No problem.
    - Use hash-function to go from string to number, so that we internally can store keys as numbers instead of strings.


TODOS: TYPE CHECKING AND COMPILING
* Type annotation and linter.
* Generics.
* How to handle compiled functions. Inlining vs jump.


TYPES
Types start with upper case. Variables start with lower case. (enforce that in syntax?)

FUNKTIONS-DEFINITIONER

Regel   symbol : typ = värde

// Type definition
Distance := Number
Distance : Type = Number
Complex := {re:Number, im:Number}
Complex : Type = {re:Number, im:Number}
x : Distance = 3
square : Number = mul[x, x]

// primitive to primitive:
square : in x:Number out Number = mul[x, x]
square : x : Number -> Number = mul[x, x]
square : x : -> = mul[x, x]
square: = x: -> mul[x, x]
square = in x out mul[x, x]

// record to primitive:
hyp : in {x:Number, y:Number} out Number = sqrt add[mul[x, x], mul[y, y]

// list to list:
conjugate : in x : List Number out List Number = [first x, neg last x]

// record to record:
conjugate : in {r:Number, i:Number} out {r:Number, i:Number} = {r := r, i := neg i}
conjugate : in Complex out Complex = {r := r, i := neg i}

// Type alias:
Complex : Type = {re:Number, im:Number}
complex := {re := 1, im := 1}
complex : Complex = {re : Number = 1, im : Number = 1}
re = re complex
im = im complex
conjugate : in {r:Number, i:Number} out {r:Number, i:Number} = {r := r, i := neg i}
conjugate : in Complex out Complex = {r := r, i := neg i}
complex2 = conjugate complex1

// Generics:
max_value : in List Generic out Generic = ...
max_index : in List Generic out Number = ...
max_split : in List Generic out List List Generic = ...

count_if : in {list: List Generic, predicate: in Generic out Boolean} out Number = ...
map: in {list: List Generic0, operation: in Generic0 out Generic1} out List Generic1 = ...
map2 : in {list0: List Generic0, list1: List Generic0, operation: in List Generic0 out Generic1} out List Generic1 = ...
map2heterogeneous : in {list0: List Generic0, list1: List Generic1, operation: in {value0: Generic0, value1: Generic1} out Generic2} out List Generic2 = ...

TYPER
*Number
*Real/Rational?
*Integer?
*Character?
*String?
*Bool?
*Dict / Class:
Vec2 = (x=Real, y=Real)
*Array?
*Enum?
*Type (The type of types. What is the type of Type itself?)


LEVELS
1. Data
   - numbers
   - characters
   - strings
   - lists
   - dictionaries
2. References
   - reference (substitution)
   - child reference (substitution)
3. Computation
   - if (substitution)
   - function definition
   - function call (substitution)
4. Imperative
   - while in dictionaries and updating of symbols (substitution)


Level 0    - Primitive data:       Numbers, Characters
Level 1    - Aggregate Data:       Lists, Strings, Dictionaries
Level 2    - References:           Reference, Child Reference
Level 3    - Branching:            Conditional
Level 4ai  - Function call:        Function call
Level 4aii - Functions definition: Function, (Function of List), (Function of Dictionary)
Level 4b   - Imperative:           Iterative dictionary

        PRIMITIVE DATA
╔══ NUMBERS ══╔═ CHARCTERS ═╗
║ 1           ║ 'a'         ║
║ 1.0         ║ 'b'         ║
║ -3.34       ║ 'c'         ║
╚═════════════╚═════════════╝

╔═ LISTS ════════════╔═ STRINGS ══════════╔═ DICTIONARIES ═════════╗
║ (EXPRESSION, ...)  ║ "CHARACTER..."     ║ {NAME=EXPRESSION, ...} ║
║                    ║                    ║                        ║
║ ()                 ║ ""                 ║ {}                     ║
║                    ║                    ║                        ║
║ (1,2,3)            ║ "abc"              ║ {width=320,height=240} ║
║                    ║                    ║                        ║
║ (                  ║ "Mang Lang"        ║ {                      ║
║     1,             ║                    ║     x = 1,             ║
║     2,             ║                    ║     y = 2,             ║
║     3              ║                    ║     z = 3              ║
║ )                  ║                    ║ }                      ║
╚════════════════════╚════════════════════╚════════════════════════╝

╔═ REFERENCES ═══════╔═ CHILD REFERENCES ══════════════════╗
║ NAME               ║ NAME@EXPRESSION                     ║
║                    ║                                     ║
║ {                  ║ {                                   ║
║     x = 1,         ║     rectangle = {width=1,height=2}, ║
║     y = x,         ║     w = width@rectangle,            ║
║     z = {a=1, b=y} ║     coordinate = z@{x=1,y=2,z=3}    ║
║ }                  ║ }                                   ║
╚════════════════════╚═════════════════════════════════════╝

╔══ CONDITIONALS ═══════════════════════════════╔══ FUNCTION APPLICATION ════════════════════╗
║ if EXPRESSION then EXPRESSION else EXPRESSION ║ NAME EXPRESSION                            ║
║                                               ║                                            ║
║ {                                             ║ {                                          ║
║     is_rich = 0,                              ║     list = (1, 2, 3),                      ║
║     money = if is_rich then 1000000 else 1,   ║     num_elements = count list,             ║
║     list = (),                                ║     longer_list = prepend(0, list),        ║
║     is_list_empty = if list then 1 else 0     ║     backwards = reverse "Mang Lang",       ║
║ }                                             ║     area = get_area{width=320, height=240} ║
║                                               ║ }                                          ║
╚═══════════════════════════════════════════════╚════════════════════════════════════════════╝

╔══ FUNCTIONS ══════════════════════════════════════╔══ FUNCTIONS OF LISTS ════════════╔══ FUNCTIONS OF DICTIONARIES ═══════════════╗
║ in NAME out EXPRESSION                            ║ in (NAME, ...) out EXPRESSION    ║ in {NAME, ...} out EXPRESSION              ║
║                                                   ║                                  ║                                            ║
║ {                                                 ║                                  ║                                            ║
║     square = in x out mul(x, x),                  ║                                  ║                                            ║
║     nine = square 3,                              ║ {                                ║                                            ║
║     square_norm2 = in vec out                     ║     square_norm2 = in (x, y) out ║                                            ║
║         add(square first vec, square second vec), ║         add(square x, square y), ║                                            ║
║     n = square_norm2(3, 4),                       ║     n = square_norm2(3, 4),      ║ {                                          ║
║     get_area = in shape out                       ║     conj = in (re, im) out       ║     get_area = in {width, height} out      ║
║         mul(width@shape, height@shape),           ║         (re, neg im),            ║         mul(width, height),                ║
║     area = get_area{width=320, height=240}        ║     c = conj(0, 1)               ║     area = get_area{width=320, height=240} ║
║ }                                                 ║ }                                ║ }                                          ║
╚═══════════════════════════════════════════════════╚══════════════════════════════════╚════════════════════════════════════════════╝

╔═ ITERATIVE DICTIONARIES ══════════════════════════════════╗
║ {NAME=EXPRESSION, while EXPRESSION, NAME=EXPRESSION, end} ║
║                                                           ║
║ {                                                         ║
║     sum = 0,                                              ║
║     i = 10,                                               ║
║     while i,                                              ║
║         i = dec i,                                        ║
║         sum = add(sum, i),                                ║
║     end                                                   ║
║ }                                                         ║
╚═══════════════════════════════════════════════════════════╝
